package scratch.kevin.simulators;

import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.math3.stat.StatUtils;
import org.opensha.commons.data.CSVFile;
import org.opensha.commons.data.function.DiscretizedFunc;
import org.opensha.commons.data.function.EvenlyDiscretizedFunc;
import org.opensha.commons.geo.Location;
import org.opensha.commons.geo.LocationUtils;
import org.opensha.commons.gui.plot.GraphWindow;
import org.opensha.commons.gui.plot.PlotCurveCharacterstics;
import org.opensha.commons.gui.plot.PlotLineType;
import org.opensha.commons.gui.plot.PlotSpec;
import org.opensha.sha.simulators.eqsim_v04.EQSIM_Event;
import org.opensha.sha.simulators.eqsim_v04.General_EQSIM_Tools;
import org.opensha.sha.simulators.eqsim_v04.RectangularElement;
import org.opensha.sha.simulators.eqsim_v04.iden.ElementIden;
import org.opensha.sha.simulators.eqsim_v04.iden.LogicalAndRupIden;
import org.opensha.sha.simulators.eqsim_v04.iden.LogicalOrRupIden;
import org.opensha.sha.simulators.eqsim_v04.iden.RuptureIdentifier;
import org.opensha.sha.simulators.eqsim_v04.iden.SectionIDIden;
import org.opensha.sha.simulators.eqsim_v04.iden.SupraSeisRupIden;

import scratch.UCERF3.logicTree.LogicalAndTrimmer;
import scratch.kevin.simulators.catBuild.RandomCatalogBuilder;
import scratch.kevin.simulators.dists.RandomDistType;

import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.primitives.Doubles;

public class PaleoOpenTests {
	
	private static class OpenIntIden {
		protected RuptureIdentifier iden;
		protected String name;
		protected double oi;
		
		public OpenIntIden(RuptureIdentifier iden, String name, double oi) {
			this.iden = iden;
			this.name = name;
			this.oi = oi;
		}
	}
	
	private static class PaleoSite extends OpenIntIden {
		private Location loc;
		
		public PaleoSite(String name, Location loc, double oi, List<RectangularElement> geom){
			this(getForLoc(name, loc, geom), name, loc, oi);
		}
		
		public PaleoSite(RuptureIdentifier iden, String name, Location loc, double oi) {
			super(iden, name, oi);
			this.loc = loc;
		}
		
		private static RuptureIdentifier getForLoc(String name, Location loc, List<RectangularElement> geom) {
			RectangularElement closest = null;
			double closestDist = Double.POSITIVE_INFINITY;
			
			for (RectangularElement el : geom) {
				Location centerLocation = el.getCenterLocation();
				double hDist = LocationUtils.horzDistanceFast(loc, centerLocation);
				if (hDist < closestDist) {
					closestDist = hDist;
					closest = el;
				}
			}
			
			System.out.println("Mapped "+name+" to "+closest.getName()+" (hDist="+(float)closestDist+" km)"
					+"\t(depth="+(float)closest.getCenterLocation().getDepth()+" km)");
			return new ElementIden(name, closest.getID());
		}
	}
	
	private static List<PaleoSite> getJacksonData(List<RectangularElement> geoms) {
		List<PaleoSite> sites = Lists.newArrayList();
		
		// this data is from Dave Jackson 1/30/2014 subject "Re: Can you send us your table?"
		sites.add(new PaleoSite("Calaveras_Fault-North", new Location(37.510, -121.835), 722d, geoms));
		sites.add(new PaleoSite("Elsinore-Glen_Ivy", new Location(33.770, -117.491), 102d, geoms));
		sites.add(new PaleoSite("Garlock-Western_(all_events)", new Location(34.987, -118.508), 330d, geoms));
		sites.add(new PaleoSite("Green_Valley-Mason_Road", new Location(38.234, -122.162), 407d, geoms));
		sites.add(new PaleoSite("Hayward_Fault-South", new Location(37.556, -121.974), 144d, geoms));
//		sites.add(new PaleoSite("Little_Salmon-Strong'sCreek", new Location(40.600, -124.122), 10890d, geoms));
		sites.add(new PaleoSite("N._SAF-Santa_Cruz_Segment", new Location(36.963, -121.698), 106d, geoms));
		sites.add(new PaleoSite("Puente Hills", new Location(33.905, -118.110), 250d, geoms));
		sites.add(new PaleoSite("Rodgers_Creek", new Location(38.262, -122.533), 304d, geoms));
		sites.add(new PaleoSite("San_Jacinto-Hog_Lake", new Location(33.615, -116.709), 243d, geoms));
		sites.add(new PaleoSite("S.SAF-Wrightwood", new Location(34.370, -117.668), 156d, geoms));
		
		return sites;
	}
	
	private static List<OpenIntIden> getMajorFaultData(List<RectangularElement> geoms) {
		List<OpenIntIden> faults = Lists.newArrayList();
		
		faults.add(new OpenIntIden(SectionIDIden.getSSAF(geoms), "S. SAF", 156));
		faults.add(new OpenIntIden(SectionIDIden.getNSAF(geoms), "N. SAF", 108));
		
		return faults;
	}
	
	private static void resetOIsIfAbove(List<? extends OpenIntIden> sites, double maxOI) {
		for (OpenIntIden site : sites)
			if (site.oi > maxOI)
				site.oi = maxOI;
	}
	
	private static double calcFractTimeInWindow(double catStartTime, double catEndTime,
			List<double[]> idenEventTimes, List<Double> idenOIs) {
		int timesInWindows = 0;
		int timeSteps = 0;
		
		timeLoop:
		for (double time=catStartTime+100d; time<catEndTime; time += 1d) {
//			if (loopCnt % 10000 == 0)
//				System.out.println("Loop "+loopCnt+"/"+expected);
//			loopCnt++;
			
			boolean match = true;
			for (int i=0; i<idenEventTimes.size(); i++) {
				double[] times = idenEventTimes.get(i);
				int bin = Arrays.binarySearch(times, time);
				double eventTime;
				if (bin >= 0) {
					eventTime = times[bin];
				} else {
					int insertionPoint = -(bin + 1);
					if (insertionPoint == 0)
						// this means we're before the first event
						continue timeLoop;
					eventTime = times[insertionPoint-1];
				}
				double oi = time - eventTime;
//				if (loopCnt % 10000 == 0) 
//					System.out.println("Debug! time="+time+"\teTime="+eventTime
//							+"\toi="+oi+"\tdataOI="+openIntervals.get(i));
				if (oi < idenOIs.get(i)) {
					match = false;
					break;
				}
			}
			timeSteps++;
			
			if (match)
				timesInWindows++;
		}
		
		double fract = (double)timesInWindows/(double)timeSteps;
		
		System.out.println(timesInWindows+"/"+timeSteps+" ("+(float)(fract*100)+" %) match data");
		
		return fract;
	}
	
	private static List<double[]> calcIdenEventTimes(List<EQSIM_Event> events, List<RuptureIdentifier> idens) {
		List<double[]> idenEventTimes = Lists.newArrayList();
		for (int i=0; i<idens.size(); i++) {
			List<EQSIM_Event> matches = idens.get(i).getMatches(events);
			double[] times = new double[matches.size()];
			for (int j=0; j<matches.size(); j++)
				times[j] = matches.get(j).getTimeInYears();
			idenEventTimes.add(times);
		}
		return idenEventTimes;
	}
	
	private static void writeSites(List<? extends OpenIntIden> sites, File file) throws IOException {
		CSVFile<String> csv = new CSVFile<String>(true);
		
		csv.addLine("Name", "Open Interval (yr)", "Element ID");
		
		for (OpenIntIden site : sites) {
			Preconditions.checkState(site.iden instanceof ElementIden, "can only write for element idens");
			String elemStr = Joiner.on(",").join(((ElementIden)site.iden).getElementIDs());
			csv.addLine(site.name, site.oi+"", elemStr);
		}
		
		csv.writeToFile(file);
	}
	
	public static void main(String[] args) throws IOException {
		File dir = new File("/home/kevin/Simulators");
		File geomFile = new File(dir, "ALLCAL2_1-7-11_Geometry.dat");
		System.out.println("Loading geometry...");
		General_EQSIM_Tools tools = new General_EQSIM_Tools(geomFile);
		List<RectangularElement> geoms = tools.getElementsList();
		
//		HashSet<String> faults = new HashSet<String>();
//		DecimalFormat df = new DecimalFormat("000");
//		for (RectangularElement elem : geoms)
//			faults.add(df.format(elem.getFaultID())+". "+elem.getSectionName());
//		List<String> faultsSorted = Lists.newArrayList(faults);
//		Collections.sort(faultsSorted);
//		for (String name : faultsSorted)
//			System.out.println(name);
//		System.exit(0);
		
		List<? extends OpenIntIden> sites = getJacksonData(geoms);
		writeSites(sites, new File("/tmp/paleo_sites.csv"));
		System.exit(0);
		
//		List<? extends OpenIntIden> sites = getMajorFaultData(geoms);
		
		boolean doRand = true;
		boolean randSplitMultis = false;
		boolean doPowerSetSearch = false;
		boolean doOIFuncGraph = true;
		
//		resetOIsIfAbove(sites, 156);
		
		List<RuptureIdentifier> idens = Lists.newArrayList();
		for (OpenIntIden site : sites)
			idens.add(site.iden);
		
		boolean supraSeismo = true;
		
		File eventFile = new File(dir, "eqs.ALLCAL2_RSQSim_sigma0.5-5_b=0.015.long.barall");
		
		System.out.println("Loading events...");
		if (supraSeismo) {
			RuptureIdentifier supraSeismoIden = new SupraSeisRupIden(tools);
			RuptureIdentifier andIden = new LogicalAndRupIden(supraSeismoIden, new LogicalOrRupIden(idens));
			tools.read_EQSIMv04_EventsFile(eventFile, Lists.newArrayList(andIden));
		} else {
			tools.read_EQSIMv04_EventsFile(eventFile, idens);
		}
		List<EQSIM_Event> events = tools.getEventsList();
		List<EQSIM_Event> randEvents = null;
		if (doRand) {
			randEvents = RandomCatalogBuilder.getRandomResampledCatalog(
					events, idens, RandomDistType.PROBABILISTIC_SHUFFLE, randSplitMultis);
			System.out.println("Rand has "+randEvents.size()+" events");
			for (int i=0; i<10; i++)
				System.out.println("\t"+randEvents.get(i).getTimeInYears());
		}
		
		boolean[] randoms;
		if (doRand)
			randoms = new boolean[] { false, true };
		else
			randoms = new boolean[] { false };
		
		if (doPowerSetSearch) {
			List<List<Double>> fracts = null;
			List<List<Double>> randFracts = null;
			for (boolean random : randoms) {
				List<EQSIM_Event> myEvents;
				if (random)
					myEvents = randEvents;
				else
					myEvents = events;
				
				List<double[]> idenEventTimes = calcIdenEventTimes(myEvents, idens);
				
				double catStartTime = myEvents.get(0).getTimeInYears();
				double catEndTime = myEvents.get(myEvents.size()-1).getTimeInYears();
				
				// indexed to set size - 1
				List<List<Double>> myFracts = Lists.newArrayList();
				for (int i=0; i<sites.size(); i++)
					myFracts.add(new ArrayList<Double>());
				
				if (random)
					randFracts = myFracts;
				else
					fracts = myFracts;
				
				HashSet<Integer> indexesList = new HashSet<Integer>();
				for (int i=0; i<sites.size(); i++)
					indexesList.add(i);
				
				HashSet<String> nevers = new HashSet<String>();
				
				List<Set<Integer>> biggestSets = null;
				int biggestSetNum = -1;
				
				for (Set<Integer> indexesSet : Sets.powerSet(indexesList)) {
					if (indexesSet.isEmpty())
						continue; // need at least one 
					System.out.println("Set: "+Joiner.on(",").join(indexesSet));
					List<double[]> subIdenEventTimes = Lists.newArrayList();
					List<Double> subOpenIntervals = Lists.newArrayList();
					for (int index : indexesSet) {
						subIdenEventTimes.add(idenEventTimes.get(index));
						subOpenIntervals.add(sites.get(index).oi);
					}
					
					double fract = calcFractTimeInWindow(catStartTime, catEndTime, subIdenEventTimes, subOpenIntervals);
					
					myFracts.get(indexesSet.size()-1).add(fract);
					
					if (fract > 0d) {
						if (indexesSet.size() > biggestSetNum) {
							biggestSets = Lists.newArrayList();
							biggestSetNum = indexesSet.size();
						}
						if (biggestSetNum == indexesSet.size())
							biggestSets.add(indexesSet);
					}
					
					if (indexesSet.size() == 1 && fract == 0d)
						nevers.add(sites.get(indexesSet.iterator().next()).name);
				}
				
				for (String never : nevers)
					System.out.println("NEVER found a match for: "+never);
				
				List<List<String>> biggestIncludes = Lists.newArrayList();
				List<List<String>> biggestExcludes = Lists.newArrayList();
				
				for (Set<Integer> set : biggestSets) {
					List<String> includeNames = Lists.newArrayList();
					List<String> excludeNames = Lists.newArrayList();
					
					for (int i=0; i<sites.size(); i++) {
						String name = sites.get(i).name;
						if (set.contains(i))
							includeNames.add(name);
						else
							excludeNames.add(name);
					}
					biggestIncludes.add(includeNames);
					biggestExcludes.add(excludeNames);
				}
				
				System.out.println("Biggest with a match was "+biggestSetNum+" long:");
				for (int i=0; i<biggestSets.size(); i++)
					System.out.println("\tIncluded: "+Joiner.on(",").join(biggestIncludes.get(i))
							+"\tExcluded: "+Joiner.on(",").join(biggestExcludes.get(i)));
			}
			
			// now make plots
			plotSetFractData(fracts, randFracts);
		}
		
		if (doOIFuncGraph) {
			double minOI = 5d;
			int numOI = 60;
			double deltaOI = 5d;
			
			double randStartTime = 0;
			double randEndTime = 0;
			double catStartTime = 0;
			double catEndTime = 0;
			List<double[]> idenEventTimes = null;
			List<double[]> randIdenEventTimes = null;
			for (boolean random : randoms) {
				List<EQSIM_Event> myEvents;
				if (random)
					myEvents = randEvents;
				else
					myEvents = events;
				
				List<double[]> myIdenEventTimes = calcIdenEventTimes(myEvents, idens);
				
				double startTime = myEvents.get(0).getTimeInYears();
				double endTime = myEvents.get(myEvents.size()-1).getTimeInYears();
				
				if (random) {
					randStartTime = startTime;
					randEndTime = endTime;
					randIdenEventTimes = myIdenEventTimes;
				} else {
					catStartTime = startTime;
					catEndTime = endTime;
					idenEventTimes = myIdenEventTimes;
				}
			}
			List<List<Integer>> subSiteIndexesLists = Lists.newArrayList();
			List<String> names = Lists.newArrayList();
			List<Integer> allSitesIndexesList = Lists.newArrayList();
			for (int i=0; i<sites.size(); i++) {
				OpenIntIden site = sites.get(i);
				subSiteIndexesLists.add(Lists.newArrayList(i));
				names.add(site.name);
				allSitesIndexesList.add(i);
			}
			if (sites.size() > 1) {
				subSiteIndexesLists.add(allSitesIndexesList);
				names.add("All Sites");
			}
			for (int j = 0; j < subSiteIndexesLists.size(); j++) {
				List<Integer> subSiteIndexes = subSiteIndexesLists.get(j);
				EvenlyDiscretizedFunc oiFunc = null;
				EvenlyDiscretizedFunc randOIFunc = null;
				
				for (boolean random : randoms) {
					EvenlyDiscretizedFunc func = new EvenlyDiscretizedFunc(minOI, numOI, deltaOI);
					double startTime, endTime;
					List<double[]> myIdenEventTimes;
					
					if (random) {
						randOIFunc = func;
						startTime = randStartTime;
						endTime = randEndTime;
						myIdenEventTimes = randIdenEventTimes;
					} else {
						oiFunc = func;
						startTime = catStartTime;
						endTime = catEndTime;
						myIdenEventTimes = idenEventTimes;
					}
					
					List<double[]> subIdenEvenTimes = Lists.newArrayList();
					for (int index : subSiteIndexes)
						subIdenEvenTimes.add(myIdenEventTimes.get(index));
					
					for (int i=0; i<numOI; i++) {
						double oi = func.getX(i);
						
						List<Double> ois = Lists.newArrayList();
						for (int index : subSiteIndexes) {
							sites.get(index).oi = oi;
							ois.add(oi);
						}
						
						double fract = calcFractTimeInWindow(startTime, endTime, subIdenEvenTimes, ois);
						
						func.set(i, fract);
					}
				}
				
				List<DiscretizedFunc> funcs = Lists.newArrayList();
				List<PlotCurveCharacterstics> chars = Lists.newArrayList();
				
				funcs.add(oiFunc);
				oiFunc.setName("RSQSim");
				chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 4f, Color.BLACK));
				if (randOIFunc != null) {
					funcs.add(randOIFunc);
					randOIFunc.setName("Randomized");
					chars.add(new PlotCurveCharacterstics(PlotLineType.DASHED, 2f, Color.GRAY));
				}
				
				PlotSpec spec = new PlotSpec(funcs, chars, names.get(j), "Open Interval (years)",
						"Fract Time In Matching Window");
				spec.setLegendVisible(true);
				
				new GraphWindow(spec);
			}
		}
	}
	
	private static void plotSetFractData(List<List<Double>> datas, List<List<Double>> randDatas) {
		EvenlyDiscretizedFunc minFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
		EvenlyDiscretizedFunc maxFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
		EvenlyDiscretizedFunc meanFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
		
		for (int i=0; i<datas.size(); i++) {
			double[] vals = Doubles.toArray(datas.get(i));
			minFunc.set(i, StatUtils.min(vals));
			maxFunc.set(i, StatUtils.max(vals));
			meanFunc.set(i, StatUtils.mean(vals));
		}
		
		List<DiscretizedFunc> funcs = Lists.newArrayList();
		List<PlotCurveCharacterstics> chars = Lists.newArrayList();
		
		funcs.add(minFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, Color.BLACK));
		funcs.add(maxFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, Color.BLACK));
		funcs.add(meanFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 4f, Color.BLACK));
		
		if (randDatas != null) {
			EvenlyDiscretizedFunc randMinFunc = new EvenlyDiscretizedFunc(1d, randDatas.size(), 1d);
			EvenlyDiscretizedFunc randMaxFunc = new EvenlyDiscretizedFunc(1d, randDatas.size(), 1d);
			EvenlyDiscretizedFunc randMeanFunc = new EvenlyDiscretizedFunc(1d, randDatas.size(), 1d);
			
			for (int i=0; i<randDatas.size(); i++) {
				double[] vals = Doubles.toArray(randDatas.get(i));
				randMinFunc.set(i, StatUtils.min(vals));
				randMaxFunc.set(i, StatUtils.max(vals));
				randMeanFunc.set(i, StatUtils.mean(vals));
			}
			
			funcs.add(randMinFunc);
			chars.add(new PlotCurveCharacterstics(PlotLineType.DASHED, 1f, Color.GRAY));
			funcs.add(randMaxFunc);
			chars.add(new PlotCurveCharacterstics(PlotLineType.DASHED, 1f, Color.GRAY));
			funcs.add(randMeanFunc);
			chars.add(new PlotCurveCharacterstics(PlotLineType.DASHED, 2f, Color.GRAY));
		}
		
		PlotSpec spec = new PlotSpec(funcs, chars, "Sim/Data Open Interval Search", "Num Paleo Sites",
				"Fract Time In Matching Window");
		
		new GraphWindow(spec);
	}

}
