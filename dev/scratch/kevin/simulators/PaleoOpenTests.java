package scratch.kevin.simulators;

import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.math3.stat.StatUtils;
import org.opensha.commons.data.function.DiscretizedFunc;
import org.opensha.commons.data.function.EvenlyDiscretizedFunc;
import org.opensha.commons.geo.Location;
import org.opensha.commons.geo.LocationUtils;
import org.opensha.commons.gui.plot.GraphWindow;
import org.opensha.commons.gui.plot.PlotCurveCharacterstics;
import org.opensha.commons.gui.plot.PlotLineType;
import org.opensha.commons.gui.plot.PlotSpec;
import org.opensha.sha.simulators.eqsim_v04.EQSIM_Event;
import org.opensha.sha.simulators.eqsim_v04.General_EQSIM_Tools;
import org.opensha.sha.simulators.eqsim_v04.RectangularElement;
import org.opensha.sha.simulators.eqsim_v04.iden.ElementIden;
import org.opensha.sha.simulators.eqsim_v04.iden.LogicalAndRupIden;
import org.opensha.sha.simulators.eqsim_v04.iden.LogicalOrRupIden;
import org.opensha.sha.simulators.eqsim_v04.iden.RuptureIdentifier;
import org.opensha.sha.simulators.eqsim_v04.iden.SectionIDIden;
import org.opensha.sha.simulators.eqsim_v04.iden.SupraSeisRupIden;

import scratch.UCERF3.logicTree.LogicalAndTrimmer;

import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.primitives.Doubles;

public class PaleoOpenTests {
	
	private static class OpenIntIden {
		protected RuptureIdentifier iden;
		protected String name;
		protected double oi;
		
		public OpenIntIden(RuptureIdentifier iden, String name, double oi) {
			this.iden = iden;
			this.name = name;
			this.oi = oi;
		}
	}
	
	private static class PaleoSite extends OpenIntIden {
		private Location loc;
		
		public PaleoSite(String name, Location loc, double oi, List<RectangularElement> geom){
			this(getForLoc(name, loc, geom), name, loc, oi);
		}
		
		public PaleoSite(RuptureIdentifier iden, String name, Location loc, double oi) {
			super(iden, name, oi);
			this.loc = loc;
		}
		
		private static RuptureIdentifier getForLoc(String name, Location loc, List<RectangularElement> geom) {
			RectangularElement closest = null;
			double closestDist = Double.POSITIVE_INFINITY;
			
			for (RectangularElement el : geom) {
				Location centerLocation = el.getCenterLocation();
				double hDist = LocationUtils.horzDistanceFast(loc, centerLocation);
				if (hDist < closestDist) {
					closestDist = hDist;
					closest = el;
				}
			}
			
			System.out.println("Mapped "+name+" to "+closest.getName()+" (hDist="+(float)closestDist+" km)"
					+"\t(depth="+(float)closest.getCenterLocation().getDepth()+" km)");
			return new ElementIden(name, closest.getID());
		}
	}
	
	private static List<PaleoSite> getJacksonData(List<RectangularElement> geoms) {
		List<PaleoSite> sites = Lists.newArrayList();
		
		// this data is from Dave Jackson 1/30/2014 subject "Re: Can you send us your table?"
		sites.add(new PaleoSite("Calaveras_Fault-North", new Location(37.510, -121.835), 722d, geoms));
		sites.add(new PaleoSite("Elsinore-Glen_Ivy", new Location(33.770, -117.491), 102d, geoms));
		sites.add(new PaleoSite("Garlock-Western_(all_events)", new Location(34.987, -118.508), 330d, geoms));
		sites.add(new PaleoSite("Green_Valley-Mason_Road", new Location(38.234, -122.162), 407d, geoms));
		sites.add(new PaleoSite("Hayward_Fault-South", new Location(37.556, -121.974), 144d, geoms));
//		sites.add(new PaleoSite("Little_Salmon-Strong'sCreek", new Location(40.600, -124.122), 10890d, geoms));
		sites.add(new PaleoSite("N._SAF-Santa_Cruz_Segment", new Location(36.963, -121.698), 106d, geoms));
		sites.add(new PaleoSite("Puente Hills", new Location(33.905, -118.110), 250d, geoms));
		sites.add(new PaleoSite("Rodgers_Creek", new Location(38.262, -122.533), 304d, geoms));
		sites.add(new PaleoSite("San_Jacinto-Hog_Lake", new Location(33.615, -116.709), 243d, geoms));
		sites.add(new PaleoSite("S.SAF-Wrightwood", new Location(34.370, -117.668), 156d, geoms));
		
		return sites;
	}
	
	private static List<OpenIntIden> getMajorFaultData(List<RectangularElement> geoms) {
		List<OpenIntIden> faults = Lists.newArrayList();
		
		faults.add(new OpenIntIden(SectionIDIden.getSSAF(geoms), "S. SAF", 156));
		faults.add(new OpenIntIden(SectionIDIden.getSSAF(geoms), "N. SAF", 108));
		
		return faults;
	}
	
	private static void resetOIsIfAbove(List<? extends OpenIntIden> sites, double maxOI) {
		for (OpenIntIden site : sites)
			if (site.oi > maxOI)
				site.oi = maxOI;
	}
	
	public static void main(String[] args) throws IOException {
		File dir = new File("/home/kevin/Simulators");
		File geomFile = new File(dir, "ALLCAL2_1-7-11_Geometry.dat");
		System.out.println("Loading geometry...");
		General_EQSIM_Tools tools = new General_EQSIM_Tools(geomFile);
		List<RectangularElement> geoms = tools.getElementsList();
		
//		HashSet<String> faults = new HashSet<String>();
//		DecimalFormat df = new DecimalFormat("000");
//		for (RectangularElement elem : geoms)
//			faults.add(df.format(elem.getFaultID())+". "+elem.getSectionName());
//		List<String> faultsSorted = Lists.newArrayList(faults);
//		Collections.sort(faultsSorted);
//		for (String name : faultsSorted)
//			System.out.println(name);
//		System.exit(0);
		
//		List<? extends OpenIntIden> sites = getJacksonData(geoms);
		
		List<? extends OpenIntIden> sites = getMajorFaultData(geoms);
		
//		resetOIsIfAbove(sites, 156);
		
		List<RuptureIdentifier> idens = Lists.newArrayList();
		for (OpenIntIden site : sites)
			idens.add(site.iden);
		
		boolean supraSeismo = true;
		
		File eventFile = new File(dir, "eqs.ALLCAL2_RSQSim_sigma0.5-5_b=0.015.long.barall");
		
		System.out.println("Loading events...");
		if (supraSeismo) {
			RuptureIdentifier supraSeismoIden = new SupraSeisRupIden(tools);
			RuptureIdentifier andIden = new LogicalAndRupIden(supraSeismoIden, new LogicalOrRupIden(idens));
			tools.read_EQSIMv04_EventsFile(eventFile, Lists.newArrayList(andIden));
		} else {
			tools.read_EQSIMv04_EventsFile(eventFile, idens);
		}
		List<EQSIM_Event> events = tools.getEventsList();
		
		List<double[]> idenEventTimes = Lists.newArrayList();
		for (int i=0; i<sites.size(); i++) {
			List<EQSIM_Event> matches = idens.get(i).getMatches(events);
			double[] times = new double[matches.size()];
			for (int j=0; j<matches.size(); j++)
				times[j] = matches.get(j).getTimeInYears();
			idenEventTimes.add(times);
		}
		
		double catStartTime = events.get(0).getTimeInYears();
		double catEndTime = events.get(events.size()-1).getTimeInYears();
		
		// indexed to set size - 1
		List<List<Double>> counts = Lists.newArrayList();
		for (int i=0; i<sites.size(); i++)
			counts.add(new ArrayList<Double>());
		List<List<Double>> fracts = Lists.newArrayList();
		for (int i=0; i<sites.size(); i++)
			fracts.add(new ArrayList<Double>());
		
		HashSet<Integer> indexesList = new HashSet<Integer>();
		for (int i=0; i<sites.size(); i++)
			indexesList.add(i);
		
		HashSet<String> nevers = new HashSet<String>();
		
		List<Set<Integer>> biggestSets = null;
		int biggestSetNum = -1;
		
		for (Set<Integer> indexesSet : Sets.powerSet(indexesList)) {
			if (indexesSet.isEmpty())
				continue; // need at least one 
			System.out.println("Set: "+Joiner.on(",").join(indexesSet));
			List<double[]> subIdenEventTimes = Lists.newArrayList();
			List<Double> subOpenIntervals = Lists.newArrayList();
			for (int index : indexesSet) {
				subIdenEventTimes.add(idenEventTimes.get(index));
				subOpenIntervals.add(sites.get(index).oi);
			}
			
			// this keeps track of the first time that the OI is defined on each section
			double populatedStartTime = Double.NaN;
			
			boolean prevWasMatch = false;
			int totNumWindows = 0;
			int timesInWindows = 0;
			int timeSteps = 0;
			
			timeLoop:
			for (double time=catStartTime+100d; time<catEndTime; time += 1d) {
//				if (loopCnt % 10000 == 0)
//					System.out.println("Loop "+loopCnt+"/"+expected);
//				loopCnt++;
				
				boolean match = true;
				for (int i=0; i<subIdenEventTimes.size(); i++) {
					double[] times = subIdenEventTimes.get(i);
					int bin = Arrays.binarySearch(times, time);
					double eventTime;
					if (bin >= 0) {
						eventTime = times[bin];
					} else {
						int insertionPoint = -(bin + 1);
						if (insertionPoint == 0)
							// this means we're before the first event
							continue timeLoop;
						eventTime = times[insertionPoint-1];
					}
					double oi = time - eventTime;
//					if (loopCnt % 10000 == 0) 
//						System.out.println("Debug! time="+time+"\teTime="+eventTime
//								+"\toi="+oi+"\tdataOI="+openIntervals.get(i));
					if (oi < subOpenIntervals.get(i)) {
						match = false;
						break;
					}
				}
				if (Double.isNaN(populatedStartTime))
					populatedStartTime = time;
				timeSteps++;
				
				if (match) {
					if (!prevWasMatch)
						// only register if the previous one wasn't a match (only count each period once)
						totNumWindows++;
					prevWasMatch = true;
					timesInWindows++;
				} else {
					prevWasMatch = false;
				}
			}
			
			double fract = (double)timesInWindows/(double)timeSteps;
			System.out.println(timesInWindows+"/"+timeSteps+" ("+(float)(fract*100)+" %) match data");
			fracts.get(indexesSet.size()-1).add(fract);
			double timeConsidered = catEndTime - populatedStartTime;
			System.out.println(totNumWindows+" matching occurances in "+(float)timeConsidered+" years");
			counts.get(indexesSet.size()-1).add((double)totNumWindows);
			
			if (totNumWindows > 0) {
				if (indexesSet.size() > biggestSetNum) {
					biggestSets = Lists.newArrayList();
					biggestSetNum = indexesSet.size();
				}
				if (biggestSetNum == indexesSet.size())
					biggestSets.add(indexesSet);
			}
			
			if (indexesSet.size() == 1 && totNumWindows == 0)
				nevers.add(sites.get(indexesSet.iterator().next()).name);
		}
		
		for (String never : nevers)
			System.out.println("NEVER found a match for: "+never);
		
		List<List<String>> biggestIncludes = Lists.newArrayList();
		List<List<String>> biggestExcludes = Lists.newArrayList();
		
		for (Set<Integer> set : biggestSets) {
			List<String> includeNames = Lists.newArrayList();
			List<String> excludeNames = Lists.newArrayList();
			
			for (int i=0; i<sites.size(); i++) {
				String name = sites.get(i).name;
				if (set.contains(i))
					includeNames.add(name);
				else
					excludeNames.add(name);
			}
			biggestIncludes.add(includeNames);
			biggestExcludes.add(excludeNames);
		}
		
		System.out.println("Biggest with a match was "+biggestSetNum+" long:");
		for (int i=0; i<biggestSets.size(); i++)
			System.out.println("\tIncluded: "+Joiner.on(",").join(biggestIncludes.get(i))
					+"\tExcluded: "+Joiner.on(",").join(biggestExcludes.get(i)));
		
		// now make plots
		plotData(counts, "Number Matching Windows");
		plotData(fracts, "Fract Time In Matching Window");
		
	}
	
	private static void plotData(List<List<Double>> datas, String yAxisLabel) {
		EvenlyDiscretizedFunc minFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
		EvenlyDiscretizedFunc maxFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
		EvenlyDiscretizedFunc meanFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
		
		for (int i=0; i<datas.size(); i++) {
			double[] vals = Doubles.toArray(datas.get(i));
			minFunc.set(i, StatUtils.min(vals));
			maxFunc.set(i, StatUtils.max(vals));
			meanFunc.set(i, StatUtils.mean(vals));
		}
		
		List<DiscretizedFunc> funcs = Lists.newArrayList();
		List<PlotCurveCharacterstics> chars = Lists.newArrayList();
		
		funcs.add(minFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, Color.BLACK));
		funcs.add(maxFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, Color.BLACK));
		funcs.add(meanFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 4f, Color.BLACK));
		
		PlotSpec spec = new PlotSpec(funcs, chars, "Sim/Data Open Interval Search", "Num Paleo Sites",
				yAxisLabel);
		
		new GraphWindow(spec);
	}

}
