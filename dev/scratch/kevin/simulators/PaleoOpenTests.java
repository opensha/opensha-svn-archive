package scratch.kevin.simulators;

import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.math3.stat.StatUtils;
import org.opensha.commons.data.function.DiscretizedFunc;
import org.opensha.commons.data.function.EvenlyDiscretizedFunc;
import org.opensha.commons.geo.Location;
import org.opensha.commons.geo.LocationUtils;
import org.opensha.commons.gui.plot.GraphWindow;
import org.opensha.commons.gui.plot.PlotCurveCharacterstics;
import org.opensha.commons.gui.plot.PlotLineType;
import org.opensha.commons.gui.plot.PlotSpec;
import org.opensha.sha.simulators.eqsim_v04.EQSIM_Event;
import org.opensha.sha.simulators.eqsim_v04.General_EQSIM_Tools;
import org.opensha.sha.simulators.eqsim_v04.RectangularElement;
import org.opensha.sha.simulators.eqsim_v04.iden.ElementIden;
import org.opensha.sha.simulators.eqsim_v04.iden.LogicalAndRupIden;
import org.opensha.sha.simulators.eqsim_v04.iden.LogicalOrRupIden;
import org.opensha.sha.simulators.eqsim_v04.iden.RuptureIdentifier;
import org.opensha.sha.simulators.eqsim_v04.iden.SupraSeisRupIden;

import scratch.UCERF3.logicTree.LogicalAndTrimmer;

import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.primitives.Doubles;

public class PaleoOpenTests {
	
	public static void main(String[] args) throws IOException {
		// this data is from Dave Jackson 1/30/2014 subject "Re: Can you send us your table?"
		List<String> names = Lists.newArrayList();
		List<Location> sites = Lists.newArrayList();
		List<Double> openIntervals = Lists.newArrayList();
		
		names.add("Calaveras_Fault-North");
		sites.add(new Location(37.510, -121.835));
		openIntervals.add(722d);
		
		// not in this sim catalog
//		names.add("Compton");
//		sites.add(new Location(33.966, -118.263));
//		openIntervals.add(1209d);
		
		names.add("Elsinore-Glen_Ivy");
		sites.add(new Location(33.770, -117.491));
		openIntervals.add(102d);

		names.add("Garlock-Western_(all_events)");
		sites.add(new Location(34.987, -118.508));
		openIntervals.add(330d);

		names.add("Green_Valley-Mason_Road");
		sites.add(new Location(38.234, -122.162));
		openIntervals.add(407d);

		names.add("Hayward_Fault-South");
		sites.add(new Location(37.556, -121.974));
		openIntervals.add(144d);

		names.add("Little_Salmon-Strong'sCreek");
		sites.add(new Location(40.600, -124.122));
		openIntervals.add(10890d);

		names.add("N._SAF-Santa_Cruz_Segment");
		sites.add(new Location(36.963, -121.698));
		openIntervals.add(106d);

		names.add("Puente Hills");
		sites.add(new Location(33.905, -118.110));
		openIntervals.add(250d);

		names.add("Rodgers_Creek");
		sites.add(new Location(38.262, -122.533));
		openIntervals.add(304d);

		names.add("San_Jacinto-Hog_Lake");
		sites.add(new Location(33.615, -116.709));
		openIntervals.add(243d);

		names.add("S.SAF-Wrightwood");
		sites.add(new Location(34.370, -117.668));
		openIntervals.add(156d);
		
		File dir = new File("/home/kevin/Simulators");
		File geomFile = new File(dir, "ALLCAL2_1-7-11_Geometry.dat");
		System.out.println("Loading geometry...");
		General_EQSIM_Tools tools = new General_EQSIM_Tools(geomFile);
		
		List<RuptureIdentifier> idens = Lists.newArrayList();
		List<Integer> elemIDs = Lists.newArrayList();
		
		// now match paleo sites
		for (int i=0; i<names.size(); i++) {
			String name = names.get(i);
			Location loc = sites.get(i);
			
			RectangularElement closest = null;
			double closestDist = Double.POSITIVE_INFINITY;
			
			for (RectangularElement el : tools.getElementsList()) {
				Location centerLocation = el.getCenterLocation();
				double hDist = LocationUtils.horzDistanceFast(loc, centerLocation);
				if (hDist < closestDist) {
					closestDist = hDist;
					closest = el;
				}
			}
			
			System.out.println("Mapped "+name+" to "+closest.getName()+" (hDist="+(float)closestDist+" km)"
					+"\t(depth="+(float)closest.getCenterLocation().getDepth()+" km)");
			idens.add(new ElementIden(name, closest.getID()));
			elemIDs.add(closest.getID());
		}
		
		boolean supraSeismo = true;
		
		File eventFile = new File(dir, "eqs.ALLCAL2_RSQSim_sigma0.5-5_b=0.015.long.barall");
		
		System.out.println("Loading events...");
		if (supraSeismo) {
			RuptureIdentifier supraSeismoIden = new SupraSeisRupIden(tools);
			RuptureIdentifier andIden = new LogicalAndRupIden(supraSeismoIden, new LogicalOrRupIden(idens));
			tools.read_EQSIMv04_EventsFile(eventFile, Lists.newArrayList(andIden));
		} else {
			tools.read_EQSIMv04_EventsFile(eventFile, idens);
		}
		List<EQSIM_Event> events = tools.getEventsList();
		
		List<double[]> idenEventTimes = Lists.newArrayList();
		for (int i=0; i<names.size(); i++) {
			List<EQSIM_Event> matches = idens.get(i).getMatches(events);
			double[] times = new double[matches.size()];
			for (int j=0; j<matches.size(); j++)
				times[j] = matches.get(j).getTimeInYears();
			idenEventTimes.add(times);
		}
		
		double catStartTime = events.get(0).getTimeInYears();
		double catEndTime = events.get(events.size()-1).getTimeInYears();
		
		// indexed to set size - 1
		List<List<Double>> counts = Lists.newArrayList();
		for (int i=0; i<names.size(); i++)
			counts.add(new ArrayList<Double>());
		
		HashSet<Integer> indexesList = new HashSet<Integer>();
		for (int i=0; i<names.size(); i++)
			indexesList.add(i);
		
		HashSet<String> nevers = new HashSet<String>();
		
		for (Set<Integer> indexesSet : Sets.powerSet(indexesList)) {
			if (indexesSet.isEmpty())
				continue; // need at least one 
			System.out.println("Set: "+Joiner.on(",").join(indexesSet));
			List<double[]> subIdenEventTimes = Lists.newArrayList();
			List<Double> subOpenIntervals = Lists.newArrayList();
			for (int index : indexesSet) {
				subIdenEventTimes.add(idenEventTimes.get(index));
				subOpenIntervals.add(openIntervals.get(index));
			}
			
			// this keeps track of the first time that the OI is defined on each section
			double populatedStartTime = Double.NaN;
			
			boolean prevWasMatch = false;
			int matchingWindows = 0;
			
			timeLoop:
			for (double time=catStartTime+100d; time<catEndTime; time += 1d) {
//				if (loopCnt % 10000 == 0)
//					System.out.println("Loop "+loopCnt+"/"+expected);
//				loopCnt++;
				
				boolean match = true;
				for (int i=0; i<subIdenEventTimes.size(); i++) {
					double[] times = subIdenEventTimes.get(i);
					int bin = Arrays.binarySearch(times, time);
					double eventTime;
					if (bin >= 0) {
						eventTime = times[bin];
					} else {
						int insertionPoint = -(bin + 1);
						if (insertionPoint == 0)
							// this means we're before the first event
							continue timeLoop;
						eventTime = times[insertionPoint-1];
					}
					double oi = time - eventTime;
//					if (loopCnt % 10000 == 0) 
//						System.out.println("Debug! time="+time+"\teTime="+eventTime
//								+"\toi="+oi+"\tdataOI="+openIntervals.get(i));
					if (oi < subOpenIntervals.get(i)) {
						match = false;
						break;
					}
				}
				if (Double.isNaN(populatedStartTime))
					populatedStartTime = time;
				
				if (match) {
					if (!prevWasMatch)
						// only register if the previous one wasn't a match (only count each period once)
						matchingWindows++;
					prevWasMatch = true;
				} else {
					prevWasMatch = false;
				}
			}
			
//			double fract = (double)matches/(double)totCats;
//			System.out.println(matches+"/"+totCats+" ("+(float)(fract*100)+" %) match data");
			double timeConsidered = catEndTime - populatedStartTime;
			System.out.println(matchingWindows+" matching occurances in "+(float)timeConsidered+" years");
			counts.get(indexesSet.size()-1).add((double)matchingWindows);
			
			if (indexesSet.size() == 1 && matchingWindows == 0)
				nevers.add(names.get(indexesSet.iterator().next()));
		}
		
		for (String never : nevers)
			System.out.println("NEVER found a match for: "+never);
		
		// now make plots
		EvenlyDiscretizedFunc minFunc = new EvenlyDiscretizedFunc(1d, names.size(), 1d);
		EvenlyDiscretizedFunc maxFunc = new EvenlyDiscretizedFunc(1d, names.size(), 1d);
		EvenlyDiscretizedFunc meanFunc = new EvenlyDiscretizedFunc(1d, names.size(), 1d);
		
		for (int i=0; i<counts.size(); i++) {
			double[] vals = Doubles.toArray(counts.get(i));
			minFunc.set(i, StatUtils.min(vals));
			maxFunc.set(i, StatUtils.max(vals));
			meanFunc.set(i, StatUtils.mean(vals));
		}
		
		List<DiscretizedFunc> funcs = Lists.newArrayList();
		List<PlotCurveCharacterstics> chars = Lists.newArrayList();
		
		funcs.add(minFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, Color.BLACK));
		funcs.add(maxFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, Color.BLACK));
		funcs.add(meanFunc);
		chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 4f, Color.BLACK));
		
		PlotSpec spec = new PlotSpec(funcs, chars, "Sim/Data Open Interval Search", "Num Paleo Sites",
				"Number Matching Windows");
		
		new GraphWindow(spec);
	}

}
