package org.opensha.sra.vulnerability;

import java.util.ArrayList;
import java.util.List;

import org.opensha.commons.data.function.ArbitrarilyDiscretizedFunc;
import org.opensha.commons.data.function.DiscretizedFunc;
import org.opensha.commons.param.ParameterList;
import org.opensha.sha.imr.param.IntensityMeasureParams.PGA_Param;
import org.opensha.sha.imr.param.IntensityMeasureParams.SA_Param;
import org.opensha.sra.asset.AssetType;
import org.opensha.sra.asset.LossType;


/**
 * Represents a probabilistic relationship between an intensity measure 
 * level (IML) and damage factor (DF) for a given structure type.  Flexible
 * enough to be used for modeling vulnerability for earthquake, wind, 
 * flood, or other hazards.
 * 
 * 
 * @author Keith Porter
 * @author Eric Martinez
 * @author Ned Field
 * @author Peter Powers
 */
public abstract class AbstractVulnerability implements Vulnerability {
	
	private String name;
	
	// NOTE: the Trackable implementation was removed, this may cause 
	// problems with this ported implementation
	
//public abstract class AbstractVulnerability implements Trackable {
//	/* These variables are useful for implementing the Trackable Interface **/
//	private static ArrayList<Trackable> registeredTypes = new ArrayList<Trackable>();
//	private static TreeMap<String, ArrayList<Trackable>> tracker = new TreeMap<String, ArrayList<Trackable>>();

//	// A list of fully qualified class names that the implementing Vulnerability Supports (i.e. IMTs, StructureTypes)
//	protected ArrayList<String> supportedTypes = null;
	
	/* These variables are useful for implementing VulnerabilityFunctions */
	public static final String SA = SA_Param.NAME;
	public static final String PGA = PGA_Param.NAME;
	private double period = 0.0;
	
	protected double ADF;
	protected double BDF;
	protected int NIML;
	
	/**
	 * Do not use this constructor.  This class is abstract.
	 */
	protected AbstractVulnerability(String name) {
		this.name = name;
	}

	
//	////////////////////////////////////////////////////////////////////////////////
//	//                    Minimum Functions to Implement Trackable                //
//	////////////////////////////////////////////////////////////////////////////////
//	/**
//	 * See the generic contract in Trackable.
//	 * @see Trackable
//	 */
//	public ArrayList<Trackable> getRegisteredTypes() {
//		return registeredTypes;
//	}
//
//	/**
//	 * See the generic contract in Trackable.
//	 * @see Trackable
//	 */
//	public ArrayList<Trackable> getSupportedTypes(Trackable obj) {
//		String tId = obj.getTrackableId();
//		ArrayList<Trackable> rtn = null;
//		if(tracker.containsKey(tId)) {
//			rtn = tracker.get(tId);
//		}
//		return rtn;
//	}
//
//	/**
//	 * See the generic contract in Trackable.
//	 * @see Trackable
//	 */
//	public String getTrackableId() {
//		String str = (this.getClass()).toString();
//		return str.substring(6);
//	}
//
//	/**
//	 * See the generic contract in Trackable.
//	 * @see Trackable
//	 */
//	public void register(ArrayList<String> types) {
//		Trackable t = (Trackable) this;
//		
//		// Add this to the list of known registered types.
//		if(registeredTypes.indexOf(t) == -1)
//			registeredTypes.add(t);
//		
//		// Add all the supported types to the tracker
//		for(int i = 0; i < types.size(); ++i) {
//			String type = types.get(i);
//			ArrayList<Trackable> supported = tracker.get(type);
//			if(supported == null)
//				supported = new ArrayList<Trackable>();
//			supported.add(t);
//			tracker.put(type, supported);
//		}
//	}
//	
//	/**
//	 * See the generic contract in Trackable.
//	 * @see Trackable
//	 */
//	public boolean equals(Object o) {
//		if(o == null) return false;
//		if(! (o instanceof StructureType) ) return false;
//		String tId = this.getTrackableId();
//		String oId = (o.getClass().toString()).substring(6);
//		return tId.equals(oId);
//	}
	
	
	////////////////////////////////////////////////////////////////////////////////
	//                               Public Functions                             //
	////////////////////////////////////////////////////////////////////////////////
	
//  not used	
//	/**
//	 * @return An <code>ArrayList</code> of currently registered <code>VulnerabilityModel</code>s
//	 */
//	public ArrayList<StructureType> getLibraryOfTypes() {
//		ArrayList<StructureType> st = new ArrayList<StructureType>();
//		for(int i = 0; i < registeredTypes.size(); ++i) {
//			st.add( ( (StructureType) registeredTypes.get(i) ) );
//		}
//		return st;
//	}
	
//  not used	
//	/**
//	 * @return An <code>ArrayList</code> of types supported by one or more of the
//	 * currently registered <code>VulnerabilityModels</code>
//	 */
//	public ArrayList<String> getSupportedTypes() {
//		return supportedTypes;
//	}
	
	
	/**
	 * @return The lower bound of the Damage Factor values associated with the implementing model
	 */
	public double getADF() {
		return ADF;
	}
	
	/**
	 * @return The upper bound of the Damage Factor values associated with the implementing model
	 */
	public double getBDF() {
		return BDF;
	}

	/**
	 * @return The return period for the implementing model.
	 */
	public double getPeriod() {
		return period;
	}

	/**
	 * Sets the return period to <code>period</code>
	 * @param period The new return period (in years).
	 */
	public void setPeriod(double period) {
		this.period = period;
	}
	
	/**
	 * @return The cannonical name used to describe this Vulnerability Model.
	 */
	public abstract String getDisplayName();

	
	/**
	 * Gets the IML values associated with the current VulnerabilityModel.  And puts
	 * them into the X-values of a new </code>DiscretizedFunc</code> object.  The 
	 * Y-values are all initialized to zero.
	 * 
	 * @return A new <code>DiscretizedFunc</code> with X-values representing the IML
	 * values for the current Vulnerability Model, and Y-Values all set to Zero.
	 */
	public DiscretizedFunc getHazardTemplate() {
		ArrayList<Double> IMLs = getIMLValues();
		DiscretizedFunc rtn = new ArbitrarilyDiscretizedFunc();
		
		for(int i = 0; i < getNIML(); ++i)
			rtn.set(IMLs.get(i), 0.0);
		return rtn;
	}
	
	/**
	 * Fetches the DF values out of the DF Lookup Table.
	 * @return An <code>ArrayList</code> of doubles representing the
	 * DF values for the current Vulnerability Model.
	 */
	public ArrayList<Double> getDFVals() {
		ArrayList<double[]> tmp = getDFTable();
		ArrayList<Double> rtn = new ArrayList<Double>();
		
		for(int i = 0; i < tmp.size(); ++i) {
			double[] entry = tmp.get(i);
			rtn.add(entry[1]);
		}
		return rtn;
	}
	
	/**
	 * @return The number of Intensity Measure Levels for the current Vulnerability Model.
	 */
	public double getNIML() {
		return NIML;
	}
	


	/* implementation */
	public ParameterList getParameters() {
		return null;
	}
	
	/* implementation */
	public void setParameter(String name, Object value) {};

	/**
	 * old javadoc: TODO clean
	 * Fetches the IML values out of the DF Lookup Table.
	 * @return An <code>ArrayList</code> of doubles representing the
	 * IML values for the current Vulnerability Model.
	 */
	/* implementation */
	public ArrayList<Double> getIMLValues() {
		ArrayList<double[]> tmp = getDFTable();
		ArrayList<Double> rtn = new ArrayList<Double>();
		
		for(int i = 0; i < tmp.size(); ++i) {
			double[] entry = tmp.get(i);
			rtn.add(entry[0]);
		}
		return rtn;
	}
	
	/* implementation */
	public double getMinIMLVal() {};
	
	/**
	 * Returns maximum IML supported by the <code>Vulnerability</code>
	 * relationship. Nonnegative real. (Can be infinity.)
	 * 
	 * @return the maximum IML value
	 */
	public Double getMaxIMLVal();
	
	/**
	 * Returns the mean loss (potentially normalized by value exposed) given
	 * an IML. Non-negative real (double).
	 * 
	 * @return the mean loss for a given IML
	 */
	public double getMeanLoss();
	
	
	/**
	 * Returns the standard deviation of loss given a value of IML. 
	 * Non-negative real (double).
	 * 
	 * @return the stadard deviation of loss for a given IML
	 */
	public double getLossStdDev();
	
	/**
	 * Returns the loss with probability P of being exceeded given P and an 
	 * IML. Non-negative real (double).
	 * 
	 * @return the loss for a given probability and IML
	 */
	public double getLossAtExceedProb();
	
	/**
	 * Returns the probability P of loss L being exceeded given L and IML.
	 * (i.e. the method returns P[LM â‰¥ L|L, IML]).
	 * Real between 0 and 1 (double).
	 * 
	 * @return the probability of a loss being exceeded for a given loss 
	 * 		and IML.
	 */
	public double getExceedProb(double loss, double iml);
	
	/* implementation */
	public AssetType getAssetType() { return null; }
	
	/* implementation */
	public LossType getLossType() { return null; }
	
	/**
	 * original javadoc: TODO clean
	 * Gets the IML values and DF values and maps them into the X,Y
	 * values (respectively) of a new <code>DiscretizedFunc</code>.
	 * 
	 * @return A <code>DiscretizedFunc</code> with X,Y values corresponding
	 * to the IML,DF values respectively.  The function will have NIML points.
	 */
	/* implementation */
	public DiscretizedFunc getVulnerabilityFunc() {
		ArrayList<Double> IMLs = getIMLValues();
		ArrayList<Double> DFs = getDFVals();
		DiscretizedFunc func = new ArbitrarilyDiscretizedFunc();
//		String modelID = (getClass()).toString();
//			return str.substring(6);

		String name = getClass().getSimpleName();//getTrackableId().replaceAll("/^.*\\./", "");
		String info = getClass().getSimpleName() + "," + getIMT() + "," + getNIML();
		
		func.setName(name);
		func.setInfo(info);
		for(int i = 0; i < getNIML(); ++i)
			func.set(IMLs.get(i), DFs.get(i));
		
		return func;
	}

	
	////////////////////////////////////////////////////////////////////////////////
	//                             Abstract Functions                             //
	////////////////////////////////////////////////////////////////////////////////
	
	
	/**
	 * The DF Lookup Table has dimension NIML x 3 and holds the IML, MDF, and COV
	 * values associated with the current Vulnerability Model.  The structure of
	 * this table is as follows:<br />
	 * <pre>
	 * 			\________________________________________________
	 * 		IML  |  IML1	IML2	IML3	....	IML(NIML)
	 * 		MDF  |	MDF1	MDF2	MDF3	....	MDF(NIML)
	 * 		COV  |	COV1	COV2	COV3	....	COV(NIML
	 * </pre>
	 * @return The DF lookup table used with the current Vulnerability Model.
	 */
	public abstract ArrayList<double[]> getDFTable();
	
	/**
	 * Interpolates the MDF values found in the DFTable for the given IML.
	 * 
	 * @param IML The desired Intensity Measure Level.
	 * @return The mean Damage Factor for the given IML.
	 */
	public abstract double getDF(double IML);

	/**
	 * Gets or creates the Damage Exceedance Matrix associated with the
	 * current vulnerability model.  This can either be precomputed and
	 * stored in memory (faster runtime, larger memory requirements), or
	 * it can be computed on the fly with an (assumed/given) distribution
	 * by using the MDF and COVDF.
	 * 
	 * @return The Damage Exceedance Matrix
	 */
	public abstract double[][] getDEMMatrix();
	
	/**
	 * Gets or computes the DF values that correspond the the Damage Exceedance
	 * Matrix.  This may or may not be the same as the regular MDF values depending
	 * on implementation.
	 * 
	 * @return The Damage Factor values associated with the DEM.
	 */
	public abstract double[] getDEMDFVals();

		
}
