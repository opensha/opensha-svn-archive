package scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.TreeMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.CharacterData;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * <p>
 * This class is used to produce discrete vulnerability models from input files.
 * The only actual implemented class discrete model is only an abstract
 * definition of what it means to be a discrete vulnerability model. One should
 * use this class to generate new vulnerability models from well-defined input
 * files. All methods in this class can be accessed statically so there is no
 * need to ever instantiate a factory.
 * </p>
 * 
 * @author <a href="mailto:emartinez@usgs.gov">Eric Martinez</a>
 * @see DiscreteVulnerability
 * @see VulnerabilityModel
 */
public class DiscreteVulnerabilityFactory {

	//---------------------------------------------------------------------------
	// Class Member Variables
	//---------------------------------------------------------------------------
	
	/**
	 * The XML document builder used to parse input files.
	 */
	private static DocumentBuilder docBuilder = null;

	/**
	 * A mapping of known probabilistic distributions with their required
	 * parameter names. K = Distribution name; V = Required parameter names.
	 */
	private static TreeMap<String, String[]> distributions = null;
	
	private static final String VULN_TYPE_PARAM_VALUE = "discrete";
	
	//----------------- XML Document Element Tag Names ------------------------//
	private static final String NAME_TAG                 = "name";
	private static final String DISPLAY_NAME_TAG         = "displayName";
	private static final String DESCRIPTION_TAG          = "description";
	private static final String DISTRIBUTION_TAG         = "distribution";
	private static final String PARAM_TAG                = "param";
	private static final String LEVEL_TAG                = "level";
	private static final String OPTION_TAG               = "option";
	
	//--------------- XML Document Element Attribute Names --------------------//
	private static final String TYPE_ATTR        = "type";
	private static final String NAME_ATTR        = "name";
	private static final String INDEX_ATTR       = "index";
	private static final String VALUE_ATTR       = "value";
	
	//--------------- XML Document Element Attribute Values -------------------//
	private static final String IML_VAL         = "imls";
	private static final String SUPT_STRUCT_VAL = "supportedStructures";
	private static final String DF_VAL          = "damageFactors";
	
	// This is returned when a requested text node is note found.
	private static final String DEFAULT_TEXT_NODE_VALUE = "UNDEFINED";
	
	
	//---------------------------------------------------------------------------
	// Initialization/Constructors
	//---------------------------------------------------------------------------
	
	/**
	 * This block performs some static initializations that are required before
	 * a vulnerability can be built from an input file. Namely it instantiates
	 * the <code>DocumentBuilder</code>.
	 */
	static {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			// Instantiate a document builder
			docBuilder = factory.newDocumentBuilder();
			
			// Define the required parameters for know distributions
			distributions = new TreeMap<String, String[]>();
			
			// Add the log normal distribution here
			distributions.put("LogNormal", new String [] {"mean",
					"covariance"});
			
			// Add more distributions...we currently only use log normal, so...
			
		} catch (ParserConfigurationException pcx) {
			// If this fails then continuing is hopeless. Die.
			pcx.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	//---------------------------------------------------------------------------
	// Public Static Methods
	//---------------------------------------------------------------------------
	
	/**
	 * Generates a new discrete vulnerability by reading the given input file.
	 * @param fileName The name of the input file to read.
	 * @return A new discrete vulnerability as defined by the input file.
	 * @throws IOException If an I/O error occurs while reading the input file.
	 * @throws SAXException If an error occurs while parsing the input file.
	 * @throws UnsupportedDistributionException If the input file tries to
	 * specify the vulnerability via a parameterized probability distribution
	 * that we are not aware of.
	 */
	public static synchronized DiscreteVulnerability createVulnerability(
			String fileName)
			throws IOException, SAXException, UnsupportedDistributionException {
		
		return createVulnerability(new FileInputStream(fileName));
	}
	
	/**
	 * Generates a new discrete vulnerability by reading the given input stream.
	 * @param in The stream to read.
	 * @return A new discrete vulnerability as defined by the input stream.
	 * @throws IOException If an I/O error occurs while reading the input stream.
	 * @throws SAXException If an error occurs while parsing the input stream.
	 * @throws UnsupportedDistributionException If the input stream tries to
	 * specify the vulnerability via a parameterized probability distribution
	 * that we are not aware of.
	 */
	public static synchronized DiscreteVulnerability createVulnerability(
			InputStream in) 
			throws IOException, SAXException, UnsupportedDistributionException {

		Element vulnInfo = docBuilder.parse(in).
				getDocumentElement();
		
		String type        = vulnInfo.getAttribute(TYPE_ATTR);
		
		if(!VULN_TYPE_PARAM_VALUE.equals(type)) {
			throw new UnsupportedDistributionException("This factory only knows " +
					"how to produce discrete vulnerabilities. You requested a " +
					"vulnerability of type: " + type);
		}
		String name        = getTextNodeValue(vulnInfo, NAME_TAG);
		String displayName = getTextNodeValue(vulnInfo, DISPLAY_NAME_TAG);
		String description = getTextNodeValue(vulnInfo, DESCRIPTION_TAG);
		String [] structs  = getNamedParameterOptions(vulnInfo, SUPT_STRUCT_VAL);
		double [] imls     = getNamedParameterLevels(vulnInfo, IML_VAL);
		double [] dfs      = getNamedParameterLevels(vulnInfo, DF_VAL);
		double [][] dem    = null;
		
		Node distNode = vulnInfo.getElementsByTagName(DISTRIBUTION_TAG).item(0);		
		if(distNode != null && distNode.getNodeType() == Node.ELEMENT_NODE) {
			// If we are here, then this discrete vulnerability is defined by a
			// probability distribution, so lets build it as such...
			
			// Get name of distribution (it must be known to us)
			String distName = distNode.getAttributes().
					getNamedItem(NAME_ATTR).getNodeValue();
			
			// Make sure we know about this probability distribution
			if(!distributions.containsKey(distName)) {
				throw new UnsupportedDistributionException();
			}

			// Get the required parameters vs. provided parameters
			TreeMap<String, double[]> paramValuesList = 
					getDistributionParameterValues((Element) distNode, distName);
			
			dem = createDEMFromDistribution(distName, paramValuesList);
		} else {
			// If we are here then this discrete vulnerability is defined by a
			// statically specifying the Damage Exceedance Matrix values along with
			// the Intensity Measure Levels and Damage Factors used to parameterize
			// the DEM.  Let's build it...
			
		} // END: if( /* Building vulnerability by Distribution or DEM */ )
		
		// If we don't have DF values yet, just use the defaults.
		if(dfs == null) {
			dfs = DiscreteVulnerability.DEFAULT_DF_VALUES;
		}
			
		return new DiscreteVulnerabilityImpl(name, displayName, description,
				structs, imls, dfs, dem);
	}
	
	//---------------------------------------------------------------------------
	// Private Utility Stuff
	//---------------------------------------------------------------------------

	private static String getTextNodeValue(
			Element scope, String parentTag) {
		try {
			NodeList children = scope.getElementsByTagName(parentTag).
				item(0).getChildNodes();
			for(int i = 0; i < children.getLength(); ++i) {
				Node child = children.item(i);
				if(child.getNodeType() == Node.TEXT_NODE &&
						!child.getNodeValue().matches("^\\s*$")) {
					return child.getNodeValue();
				} else if (child.getNodeType() == Node.CDATA_SECTION_NODE) {
					// CDATA can only have a single child, namely, the text data.
					return ( (CharacterData) child).getData();
				}
			}
			// If we didn't find a good value, then return a default string...
			return DEFAULT_TEXT_NODE_VALUE;
		} catch (NullPointerException npx) {
			// If the named parentTag is not found or has no children then a
			// null pointer exception might get thrown so we'll return a default
			// string rather than die.
			return DEFAULT_TEXT_NODE_VALUE;
		}
	}
	
	private static TreeMap<String, double[]> getDistributionParameterValues(
			Element distNode, String distName)
			throws UnsupportedDistributionException {
		TreeMap<String, double[]> params = new TreeMap<String, double[]>();
		
		String [] requiredParams = distributions.get(distName);
		for(int i = 0; i < requiredParams.length; ++i) {
			String paramName = requiredParams[i];
			double [] paramVals = getNamedParameterLevels(distNode, paramName);
			if(paramVals == null) {
				throw new UnsupportedDistributionException("The requested " +
						"distribution requires a parameter named \"" + paramName +
						"\" but this parameter was not found in the provided data.");
			}
			// Add the parameter values...
			params.put(paramName, paramVals);
		}
		
		return params;
	}
	
	private static double[] getNamedParameterLevels(Element scope, String name) {
		NodeList possibleParams = scope.getElementsByTagName(PARAM_TAG);
	
		for(int i = 0; i < possibleParams.getLength(); ++i) {
			String paramName = possibleParams.item(i).getAttributes().
					getNamedItem(NAME_ATTR).getNodeValue();
			
			if(name.equals(paramName)) {
				// We have found the named parameter, so get the values
				return getParameterLevels( (Element) possibleParams.item(i));
			}
		}
		
		// If the named parameter is not found, return null
		return null;
	}
	
	private static double [] getParameterLevels(Element parameter) {
		double [] levelVals = null;
		
		NodeList levelNodes = parameter.getElementsByTagName(LEVEL_TAG);
		int levelCount = levelNodes.getLength();
		levelVals = new double[levelCount];
		
		for(int i = 0; i < levelCount; ++i) {
			Node level = levelNodes.item(i);
			int index = Integer.parseInt(
					level.getAttributes().getNamedItem(INDEX_ATTR).getNodeValue());
			double value = Double.parseDouble(
					level.getAttributes().getNamedItem(VALUE_ATTR).getNodeValue());
			
			if(index != i) {
				// Declared index does not match display order. Print a warning.
				System.err.println("Declared index (" + index + ") does not " +
						"match the displayed index order (" + i + "). Using the " +
						"displayed index order.");
			}
			
			levelVals[i] = value;
		}
		
		return levelVals;
	}
	
	private static String [] getNamedParameterOptions(
			Element scope, String name) {
		NodeList possibleParams = scope.getElementsByTagName(PARAM_TAG);
		
		for(int i = 0; i < possibleParams.getLength(); ++i) {
			String paramName = possibleParams.item(i).getAttributes().
					getNamedItem(NAME_ATTR).getNodeValue();
			
			if(name.equals(paramName)) {
				// We have found the named parameter, so get the values
				return getParameterOptions( (Element) possibleParams.item(i));
			}
		}
		
		// If the named parameter is not found, return null
		return null;
	}
	
	private static String [] getParameterOptions(Element parameter) {
		String [] optionVals = null;
		
		NodeList optionNodes = parameter.getElementsByTagName(OPTION_TAG);
		int optionCount = optionNodes.getLength();
		optionVals = new String[optionCount];
		
		for(int i = 0; i < optionCount; ++i) {
			Node option = optionNodes.item(i);
			int index = Integer.parseInt(
					option.getAttributes().getNamedItem(INDEX_ATTR).getNodeValue());
			String value = option.getAttributes().getNamedItem(VALUE_ATTR).
					getNodeValue();
			
			if(index != i) {
				// Declared index does not match display order. Print a warning.
				System.err.println("Declared index (" + index + ") does not " +
						"match the displayed index order (" + i + "). Using the " +
						"displayed index order.");
			}
			
			optionVals[i] = value;
		}
		
		return optionVals;
	}
	
	public static double[][] createDEMFromDistribution(String distName,
			TreeMap<String, double[]> paramValueList) {
		return null;
	}
	
	//---------------------------------------------------------------------------
	// This is a private inner class the implements the
	// <code>DiscreteVulnerability</code> abstract class.
	//---------------------------------------------------------------------------
	
	private static class DiscreteVulnerabilityImpl
			extends DiscreteVulnerability {
		//------------------------------------------------------------------------
		// Member Variables
		//------------------------------------------------------------------------
		private double [][] dem = null;
		private double [] dfs = null;
		private double [] imls = null;
		private String displayName = null;
		private String name = null;
		private String [] supportedStructs = null;
		private String description;
		

		//------------------------------------------------------------------------
		// Constructor(s)
		//------------------------------------------------------------------------
		
		public DiscreteVulnerabilityImpl(String name, String displayName,
				String description, String [] supportedStructs, double [] imls, 
				double [] dfs, double [][] dem) {
			
			if(name == null || displayName == null || description == null ||
					supportedStructs == null || imls == null || dfs == null) {
				IllegalArgumentException iax = new IllegalArgumentException(
						"One or more parameters passed to the consctructor were " +
						"null. Please check your parameters and try again."
					);
				iax.fillInStackTrace();
				throw iax;
			}
			
			this.name             = name;
			this.displayName      = displayName;
			this.description      = description;
			this.supportedStructs = supportedStructs;
			this.imls             = imls;
			this.dfs              = dfs;
			this.dem              = dem;
		}
		

		//------------------------------------------------------------------------
		// Public Methods
		//------------------------------------------------------------------------

		//---------------------- Public Getter Methods -------------------------//
		
		public double[][] getDEM()                  { return dem;              }
		public double[] getDFValues()               { return dfs;              }
		public double[] getIMLValues()              { return imls;             }
		public String getDisplayName()              { return displayName;      }
		public String getName()                     { return name;             }
		public String[] getSupportedStructures()    { return supportedStructs; }
		public String getDescription() { return description;      }
		
		//------------------------- No Setter Methods --------------------------//
		
		//----------------------- Public Utility Methods -----------------------//
		public String toString() {
			StringBuffer buf = new StringBuffer();
			buf.append("Vulnerability Name : " + getDisplayName() + "\n");
			buf.append("Vulnerability ID :   " + getName() + "\n");
			
			buf.append("Supported Structures:\n");
			for(int i = 0; i < supportedStructs.length; ++i) {
				buf.append("   -- " + supportedStructs[i] + "\n");
			}
			
			buf.append("Description:\n");
			buf.append("   " + getDescription() + "\n");
			
			buf.append("Intensity Measure Levels:\n{\n");
			for(int i = 0; i < imls.length;) {
				buf.append("   " + String.format("%5.4f", imls[i]));
				if( (++i%8) == 0) { buf.append("\n"); }
			}
			buf.append("\n}\n");
			
			buf.append("Damage Factors:\n{\n");
			for(int i = 0; i < dfs.length;) {
				buf.append("   " + String.format("%5.3e", dfs[i]));
				if( (++i%6) == 0) { buf.append("\n"); }
			}
			buf.append("\n}\n");
			
			return buf.toString().replace("\n\n", "\n");
		}

		//------------------------------------------------------------------------
		// Private Methods
		//------------------------------------------------------------------------
		
	} // END: DiscreteVulnerabilityImpl
	
}
