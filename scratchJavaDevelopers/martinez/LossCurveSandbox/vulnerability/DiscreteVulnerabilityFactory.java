package scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.TreeMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.CharacterData;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * <p>
 * This class is used to produce discrete vulnerability models from input files.
 * The only actual implemented class discrete model is only an abstract
 * definition of what it means to be a discrete vulnerability model. One should
 * use this class to generate new vulnerability models from well-defined input
 * files. All methods in this class can be accessed statically so there is no
 * need to ever instantiate a factory.
 * </p>
 * 
 * @author <a href="mailto:emartinez@usgs.gov">Eric Martinez</a>
 * @see DiscreteVulnerability
 * @see VulnerabilityModel
 */
public class DiscreteVulnerabilityFactory {

	//---------------------------------------------------------------------------
	// Class Member Variables
	//---------------------------------------------------------------------------
	
	/**
	 * The XML document builder used to parse input files.
	 */
	private static DocumentBuilder docBuilder = null;

	/**
	 * A mapping of known probabilistic distributions with their required
	 * parameter names. K = Distribution name; V = Required parameter names.
	 */
	private static TreeMap<String, String[]> distributions = null;
	
	private static final String VULN_TYPE_PARAM_VALUE = "discrete";
	//----------------- XML Document Element Tag Names ------------------------//
	private static final String VULNERABILITY_TAG        = "vulnerability";
	private static final String NAME_TAG                 = "name";
	private static final String DISPLAY_NAME_TAG         = "displayName";
	private static final String SUPPORTED_STRUCTURES_TAG = "supportedStructures";
	private static final String STRUCTURE_TAG            = "structure";
	private static final String DESCRIPTION_TAG          = "description";
	private static final String DISTRIBUTION_TAG         = "distribution";
	private static final String PARAM_TAG                = "param";
	private static final String LEVEL_TAG                = "level";
	
	//--------------- XML Document Element Attribute Names --------------------//
	private static final String TYPE_ATTR  = "type";
	private static final String NAME_ATTR  = "name";
	private static final String INDEX_ATTR = "index";
	private static final String VALUE_ATTR = "value";
	private static final String IMLS_ATTR  = "imls";
	
	// This is returned when a requested text node is note found.
	private static final String DEFAULT_TEXT_NODE_VALUE = "UNDEFINED";
	
	
	//---------------------------------------------------------------------------
	// Initialization/Constructors
	//---------------------------------------------------------------------------
	
	/**
	 * This block performs some static initializations that are required before
	 * a vulnerability can be built from an input file. Namely it instantiates
	 * the <code>DocumentBuilder</code>.
	 */
	static {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			// Instantiate a document builder
			docBuilder = factory.newDocumentBuilder();
			
			// Define the required parameters for know distributions
			distributions = new TreeMap<String, String[]>();
			
			// Add the log normal distribution here
			distributions.put("LogNormal", new String [] {"mean",
					"covariance"});
			
			// Add more distributions...we currently only use log normal, so...
			
		} catch (ParserConfigurationException pcx) {
			// If this fails then continuing is hopeless. Die.
			pcx.printStackTrace(System.err);
			System.exit(-1);
		}
	}
	
	//---------------------------------------------------------------------------
	// Public Static Methods
	//---------------------------------------------------------------------------
	
	/**
	 * Generates a new discrete vulnerability by reading the given input file.
	 * @param fileName The name of the input file to read.
	 * @return A new discrete vulnerability as defined by the input file.
	 * @throws IOException If an I/O error occurs while reading the input file.
	 * @throws SAXException If an error occurs while parsing the input file.
	 * @throws UnsupportedDistributionException If the input file tries to
	 * specify the vulnerability via a parameterized probability distribution
	 * that we are not aware of.
	 */
	public static synchronized DiscreteVulnerability createVulnerability(
			String fileName)
			throws IOException, SAXException, UnsupportedDistributionException {
		
		return createVulnerability(new FileInputStream(fileName));
	}
	
	/**
	 * Generates a new discrete vulnerability by reading the given input stream.
	 * @param in The stream to read.
	 * @return A new discrete vulnerability as defined by the input stream.
	 * @throws IOException If an I/O error occurs while reading the input stream.
	 * @throws SAXException If an error occurs while parsing the input stream.
	 * @throws UnsupportedDistributionException If the input stream tries to
	 * specify the vulnerability via a parameterized probability distribution
	 * that we are not aware of.
	 */
	public static synchronized DiscreteVulnerability createVulnerability(
			InputStream in) 
			throws IOException, SAXException, UnsupportedDistributionException {

		Element vulnInfo = docBuilder.parse(in).
				getDocumentElement();
		
		String type        = vulnInfo.getAttribute(TYPE_ATTR);
		String name        = getTextNodeValue(vulnInfo, NAME_TAG);
		String displayName = getTextNodeValue(vulnInfo, DISPLAY_NAME_TAG);
		String description = getTextNodeValue(vulnInfo, DESCRIPTION_TAG);
		Double [] imls     = getNamedParameterLevels(vulnInfo, IMLS_ATTR);
		
		Node distNode = vulnInfo.getElementsByTagName(DISTRIBUTION_TAG).item(0);		
		if(distNode != null && distNode.getNodeType() == Node.ELEMENT_NODE) {
			// If we are here, then this discrete vulnerability is defined by a
			// probability distribution, so lets build it as such...
			
			// Get name of distribution (it must be known to us)
			String distName = distNode.getAttributes().
					getNamedItem(NAME_ATTR).getNodeValue();
			
			// Make sure we know about this probability distribution
			if(!distributions.containsKey(distName)) {
				throw new UnsupportedDistributionException();
			}

			// Get the required parameters vs. provided parameters
			TreeMap<String, Double[]> paramValuesList = 
					getDistributionParameterValues((Element) distNode, distName);
			
		} else {
			// If we are here then this discrete vulnerability is defined by a
			// statically specifying the Damage Exceedance Matrix values along with
			// the Intensity Measure Levels and Damage Factors used to parameterize
			// the DEM.  Let's build it...
			
		} // END: if( /* Building vulnerability by Distribution or DEM */ )
		
		
		return null;
	}
	
	//---------------------------------------------------------------------------
	// Private Utility Stuff
	//---------------------------------------------------------------------------

	private static String getTextNodeValue(
			Element scope, String parentTag) {
		try {
			NodeList children = scope.getElementsByTagName(parentTag).
				item(0).getChildNodes();
			for(int i = 0; i < children.getLength(); ++i) {
				Node child = children.item(i);
				if(child.getNodeType() == Node.TEXT_NODE &&
						!child.getNodeValue().matches("^\\s*$")) {
					return child.getNodeValue();
				} else if (child.getNodeType() == Node.CDATA_SECTION_NODE) {
					// CDATA can only have a single child, namely, the text data.
					return ( (CharacterData) child).getData();
				}
			}
			// If we didn't find a good value, then return a default string...
			return DEFAULT_TEXT_NODE_VALUE;
		} catch (NullPointerException npx) {
			// If the named parentTag is not found or has no children then a
			// null pointer exception might get thrown so we'll return a default
			// string rather than die.
			return DEFAULT_TEXT_NODE_VALUE;
		}
	}
	
	private static TreeMap<String, Double[]> getDistributionParameterValues(
			Element distNode, String distName)
			throws UnsupportedDistributionException {
		TreeMap<String, Double[]> params = new TreeMap<String, Double[]>();
		
		String [] requiredParams = distributions.get(distName);
		for(int i = 0; i < requiredParams.length; ++i) {
			String paramName = requiredParams[i];
			Double [] paramVals = getNamedParameterLevels(distNode, paramName);
			if(paramVals == null) {
				throw new UnsupportedDistributionException("The requested " +
						"distribution requires a parameter named \"" + paramName +
						"\" but this parameter was not found in the provided data.");
			}
			// Add the parameter values...
			params.put(paramName, paramVals);
		}
		
		return params;
	}
	
	private static Double[] getNamedParameterLevels(Element scope, String name) {
		NodeList possibleParams = scope.getElementsByTagName(PARAM_TAG);
	
		for(int i = 0; i < possibleParams.getLength(); ++i) {
			String paramName = possibleParams.item(i).getAttributes().
					getNamedItem(NAME_ATTR).getNodeValue();
			
			if(name.equals(paramName)) {
				// We have found the named parameter, so get the values
				return getParameterLevels( (Element) possibleParams.item(i));
			}
		}
		
		// If the named parameter is not found, return null
		return null;
	}
	
	private static Double [] getParameterLevels(Element parameter) {
		Double [] levelVals = null;
		
		NodeList levelNodes = parameter.getElementsByTagName(LEVEL_TAG);
		int levelCount = levelNodes.getLength();
		levelVals = new Double[levelCount];
		
		for(int i = 0; i < levelCount; ++i) {
			Node level = levelNodes.item(i);
			int index = Integer.parseInt(
					level.getAttributes().getNamedItem(INDEX_ATTR).getNodeValue());
			double value = Double.parseDouble(
					level.getAttributes().getNamedItem(VALUE_ATTR).getNodeValue());
			
			if(index != i) {
				// Declared index does not match display order. Print a warning.
				System.err.println("Declared index (" + index + ") does not " +
						"match the displayed index order (" + i + "). Using the " +
						"displayed index order.");
			}
			
			levelVals[i] = value;
		}
		
		return levelVals;
	}
	
	private static String [] getNamedParameterOptions(
			Element scope, String name) {
		NodeList possibleParams = scope.getElementsByTagName(PARAM_TAG);
		
		for(int i = 0; i < possibleParams.getLength(); ++i) {
			String paramName = possibleParams.item(i).getAttributes().
					getNamedItem(NAME_ATTR).getNodeValue();
			
			if(name.equals(paramName)) {
				// We have found the named parameter, so get the values
				return getParameterOptions( (Element) possibleParams.item(i));
			}
		}
		
		// If the named parameter is not found, return null
		return null;
	}
	
	private static String [] getParameterOptions(Element parameter) {
		return null;
	}
}
