package scratchJavaDevelopers.martinez.LossCurveSandbox.beans;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.TreeMap;

import org.xml.sax.SAXException;

import scratchJavaDevelopers.martinez.LossCurveSandbox.ui.
		VulnerabilityBeanEditor;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		DiscreteVulnerabilityFactory;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		IllegalVulnerabilityFormatException;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		UnsupportedDistributionException;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		VulnerabilityModel;

/**
 * A vulnerability bean is a widget component used to store information about
 * vulnerabilities. Vulnerabilities are loaded from input data files (some by
 * default, and others can be loaded from the user). Once the vulnerability is
 * loaded it is considered to be &ldquo;known&rdquo;. Additionally, there is a
 * concept of availability. In its initial implementation, all vulnerabilities
 * are available all the time, however in reality this makes less sense. Certain
 * vulnerabilities are only meant to be used with certain structures (this is a
 * many-to-many relationship). Once the concept of different structure types is
 * implemented then this class should be refactored to include that
 * functionality as well.
 * 
 * @author <a href="mailto:emartinez@usgs.gov">Eric Martinez</a>
 *
 */
public class VulnerabilityBean implements BeanAPI {
	
	//---------------------------------------------------------------------------
	// Member Variables
	//---------------------------------------------------------------------------
	
	// Explicitly declared for serialization.
	private static final long serialVersionUID = 0x2F9E201;
	
	/**
	 * The currently selected vulnerability model.
	 */
	private VulnerabilityModel currentModel = null;
	/**
	 * A mapping of known models with their  respective names.
	 */
	private TreeMap<String, VulnerabilityModel> knownModels = null;
	/**
	 * A mapping of currently available models with their corresponding names.
	 */
	private TreeMap<String, VulnerabilityModel> availableModels = null;
	/**
	 * The editor used to manipulate values on this bean.
	 */
	private VulnerabilityBeanEditor editor = null;

	//---------------------------------------------------------------------------
	// Constructors/Initializers
	//---------------------------------------------------------------------------

	/**
	 * A default no-arg constructor. Initializes required variables such that
	 * subsequent call to this bean should not directly cause an exception. This
	 * constructor loads vulnerabilities from the default location and lists
	 * them as available to a caller.
	 */
	public VulnerabilityBean() {
		knownModels = new TreeMap<String, VulnerabilityModel>();
		
		// Add all the known models as available.
		availableModels.putAll(knownModels);
	}
	
	//---------------------------------------------------------------------------
	// Public Methods
	//---------------------------------------------------------------------------
	
	//---------------------- Public Setter Methods ----------------------------//
	
	/**
	 * Sets the <code>currentModel</code> to the given <code>model</code>.
	 * 
	 * @param model The vulnerability model to set as current.
	 * @throws UnavailableVulnerabilityException If the given model is not
	 * currently available.
	 */
	public void setCurrentModel(VulnerabilityModel model) 
			throws UnavailableVulnerabilityException {
		setCurrentModel(model.getName());
	}
	
	/**
	 * Searches for the vulnerability model with the given
	 * <code>modelName</code>. If it is found, then <code>currentModel</code> is
	 * set to the corresponding model. If the specified model is not currently
	 * listed as available, then an
	 * <code>UnavailableVulnerabilityException</code> is thrown.
	 * 
	 * @param modelName
	 * @throws UnavailableVulnerabilityException If the
	 */
	public void setCurrentModel(String modelName)
			throws UnavailableVulnerabilityException {
		if(!availableModels.containsKey(modelName)) {
			throw new UnavailableVulnerabilityException(modelName + " is not " + 
					"currently listed as an available vulnerability model.",
					getCurrentModel().getName(), modelName);
		}
		this.currentModel = availableModels.get(modelName);
	}
	
	/**
	 * Enables the specified model.
	 * @param model The model to enable.
	 */
	public void enableModel(VulnerabilityModel model) {
		try {
			enableModel(model.getName());
		} catch (NullPointerException npx) {
			// Null pointer happens when this model is not yet known about. So to
			// solve this we load it and then (via the true), enable it.
			loadVulnerability(model, true);
		}
	}
	
	/**
	 * Enables the specified model.
	 * @param model The name of the model to enable.
	 * @throws NullPointerException If the model is not currently known.
	 */
	public void enableModel(String modelName) {
		if(!isAvailable(modelName)) { // We don't have to do anything otherwise...
			VulnerabilityModel model = knownModels.get(modelName);
			if(model == null) {
				throw new NullPointerException("I can't enable a model I don't " +
						"know about!");
			}
			
			availableModels.put(modelName, model);
		}
	}
	
	//---------------------- Public Getter Methods ----------------------------//
	
	/**
	 * @return The currently selected vulnerability model.
	 */
	public VulnerabilityModel getCurrentModel() {
		return currentModel;
	}
	
	/**
	 * @return A list of available vulnerability models.
	 */
	public TreeMap<String, VulnerabilityModel> getAvailableModels() {
		return availableModels;
	}
	
	/**
	 * @return A list of known vulnerability models.
	 */
	public TreeMap<String, VulnerabilityModel> getKnownModels() {
		return knownModels;
	}
	
	/**
	 * @return The editor used to manipulate this bean.
	 */
	public VulnerabilityBeanEditor getBeanEditor() {
		return editor;
	}
	
	/**
	 * Checks whether or not a specific vulnerability is currently loaded.
	 * 
	 * @param model The vulnerability to look for.
	 * @return <code>true</code> if the vulnerability is loaded, 
	 * <code>false</code> otherwise.
	 */
	public boolean isKnown(VulnerabilityModel model) {
		return isKnown(model.getName());
	}
	
	/**
	 * Checks whether or not a specific vulnerability is currently loaded.
	 * 
	 * @param modelName The name of the vulnerability to look for.
	 * @return <code>true</code> if the vulnerability is loaded, 
	 * <code>false</code> otherwise.
	 */
	public boolean isKnown(String modelName) {
		return knownModels.containsKey(modelName);
	}
	
	/**
	 * Checks whether or not a specific vulnerability is currently available.
	 * 
	 * @param model The vulnerability to look for.
	 * @return <code>true</code> if the vulnerability is available, 
	 * <code>false</code> otherwise.
	 */
	public boolean isAvailable(VulnerabilityModel model) {
		return isAvailable(model.getName());
	}
	
	/**
	 * Checks whether or not a specific vulnerability is currently available.
	 * 
	 * @param modelName The name of the vulnerability to look for.
	 * @return <code>true</code> if the vulnerability is available, 
	 * <code>false</code> otherwise.
	 */
	public boolean isAvailable(String modelName) {
		return availableModels.containsKey(modelName);
	}
	
	//---------------------- Public Utility Methods ---------------------------//
	
	/**
	 * Uses a vulnerability factory to read a file specified by the given
	 * <code>fileName</code> and parse the data into a usable vulnerability. If
	 * the file specifies a directory, then that directory is recursively
	 * searched for vulnerability files and those are loaded.
	 * 
	 * @param fileName The name of the file from which to read the vulnerability
	 * definition.
	 * @param isAvailable If the vulnerability should be considered
	 * &ldquo;available&rdquo; after it is loaded.
	 * <code>false</code> if exceptions should just be treated as warnings.
	 * 
	 * @throws FileNotFoundException If the given file does not exist.
	 * @throws IOException If an I/O error occurs while reading the stream.
	 * @throws NullPointerException If the factory creating the model for some
	 * reason returns <code>null</code>.
	 * @throws SAXException If the data read from the input stream does not
	 * parse as valid XML.
	 * @throws UnsupportedDistributionException If the data read from the input
	 * stream requests a distribution we don't know about.
	 */
	public void loadVulnerability(String fileName, boolean isAvailable)
			throws FileNotFoundException, IOException, NullPointerException,
			SAXException, UnsupportedDistributionException {
		if(fileName == null || "".equals(fileName)) {
			NullPointerException npx = new NullPointerException(
					"Cannot create a vulnerability from an unspecified file."
				);
			npx.fillInStackTrace();
			throw npx;
		}
		
		loadVulnerability(new File(fileName), isAvailable);
	}
	
	/**
	 * Uses a vulnerability factory to read the given <code>inputFile</code> and
	 * parse the data into a usable vulnerability. If the file specifies a
	 * directory, then that directory is recursively searched for vulnerability
	 * files and those are loaded.
	 * 
	 * @param inputFile The file from which to read the vulnerability
	 * definition.
	 * @param isAvailable If the vulnerability should be considered
	 * &ldquo;available&rdquo; after it is loaded.
	 * <code>false</code> if exceptions should just be treated as warnings.
	 * 
	 * @throws FileNotFoundException If the given file does not exist.
	 * @throws IOException If an I/O error occurs while reading the stream.
	 * @throws NullPointerException If the factory creating the model for some
	 * reason returns <code>null</code>.
	 * @throws SAXException If the data read from the input stream does not
	 * parse as valid XML.
	 * @throws UnsupportedDistributionException If the data read from the input
	 * stream requests a distribution we don't know about.
	 */
	
	public void loadVulnerability(File inputFile, boolean isAvailable) 
			throws FileNotFoundException, IOException, NullPointerException,
			SAXException, UnsupportedDistributionException {
		
		// Make sure this file exists before trying to parse it
		if(!inputFile.exists()) {
			FileNotFoundException fnx = new FileNotFoundException(
					"Could not find the specified file (" + 
					inputFile.getAbsolutePath() + ")."
				);
			fnx.fillInStackTrace();
			throw fnx;
		}
		
		// Check if this is a directory or a regular file
		if(inputFile.isDirectory()) {
			loadRecursiveVulnerabilities(inputFile, isAvailable);
		} else {
			loadVulnerability(new FileInputStream(inputFile), isAvailable);
		}
	}
	
	/**
	 * Uses a vulnerability factory to read the given <code>inputFile</code> and
	 * parse the data into a usable vulnerability. If the file specifies a
	 * directory, then that directory is recursively searched for vulnerability
	 * files and those are loaded.
	 * 
	 * @param inputFile The file from which to read the vulnerability
	 * definition.
	 * @param isAvailable If the vulnerability should be considered
	 * &ldquo;available&rdquo; after it is loaded.
	 * <code>false</code> if exceptions should just be treated as warnings.
	 * 
	 * @throws FileNotFoundException If the given file does not exist.
	 * @throws IOException If an I/O error occurs while reading the stream.
	 * @throws NullPointerException If the factory creating the model for some
	 * reason returns <code>null</code>.
	 * @throws SAXException If the data read from the input stream does not
	 * parse as valid XML.
	 * @throws UnsupportedDistributionException If the data read from the input
	 * stream requests a distribution we don't know about.
	 */
	public void loadRecursiveVulnerabilities(File inputFile, boolean isAvailable) 
			throws FileNotFoundException, IOException, NullPointerException,
			SAXException, UnsupportedDistributionException  {
		
		// Make sure this file exists before trying to parse it
		if(!inputFile.exists()) {
			FileNotFoundException fnx = new FileNotFoundException(
					"Could not find the specified file (" + 
					inputFile.getAbsolutePath() + ")."
				);
			fnx.fillInStackTrace();
			throw fnx;
		}
		
		// Check if we need to recurse further...
		if(inputFile.isDirectory()) {
			File [] fileList = inputFile.listFiles();
			for(int i = 0; i < fileList.length; ++i) {
				// This is directory, so recursively search for an XML file
				loadRecursiveVulnerabilities(fileList[i], isAvailable);
			} // END: for(fileList)
		} else {
			if (inputFile.getName().contains("vulnerability.xml")) {
				// This should be a vulnerability, so parse it
				loadVulnerability(inputFile, isAvailable);
			} else if (inputFile.getName().endsWith(".xml")) {
				// This might be a vulnerability, so ask the user if this arbitrary
				// XML file is a supposed to be vulnerability
				if(editor.boolPrompt("The file + " + inputFile.getName() + " is " +
						"an XML file and may define a vulnerability. Would you " +
						"like to attempt to load a vulnerability from this file?" +
						"(Failure to load will result in a warning rather than " +
						"a fatal error).", true)
					) {
					// Let user decide if they want to die on error
					loadVulnerability(new FileInputStream(inputFile), isAvailable,
							editor.boolPrompt("Should unsuccessful parsing of " +
									"this file result in an error?", false));
				} // END: if(prompt)
			}
		} // END: if(inputFile is Directory)
	}
	
	/**
	 * Uses a vulnerability factory to read the given <code>inputStream</code>
	 * and parse the data into a usable vulnerability.
	 * 
	 * @param inputStream The stream from which to read the vulnerability
	 * definition.
	 * @param isAvailable If the vulnerability should be considered
	 * &ldquo;available&rdquo; after it is loaded.
	 * <code>false</code> if exceptions should just be treated as warnings.
	 * 
	 * @throws IOException If an I/O error occurs while reading the stream.
	 * @throws NullPointerException If the factory creating the model for some
	 * reason returns <code>null</code>.
	 * @throws SAXException If the data read from the input stream does not
	 * parse as valid XML.
	 * @throws UnsupportedDistributionException If the data read from the input
	 * stream requests a distribution we don't know about.
	 */
	public void loadVulnerability(InputStream  inputStream, boolean isAvailable)
			throws IOException, NullPointerException, SAXException,
			UnsupportedDistributionException {
		loadVulnerability(inputStream, isAvailable, true);
	}
	
	/**
	 * Uses a vulnerability factory to read the given <code>inputStream</code>
	 * and parse the data into a usable vulnerability.
	 * 
	 * @param inputStream The stream from which to read the vulnerability
	 * definition.
	 * @param isAvailable If the vulnerability should be considered
	 * &ldquo;available&rdquo; after it is loaded.
	 * @param dieOnError <code>true</code> if exceptions should be thrown,
	 * <code>false</code> if exceptions should just be treated as warnings.
	 * 
	 * @throws IOException If an I/O error occurs while reading the stream.
	 * @throws NullPointerException If the factory creating the model for some
	 * reason returns <code>null</code>.
	 * @throws SAXException If the data read from the input stream does not
	 * parse as valid XML.
	 * @throws UnsupportedDistributionException If the data read from the input
	 * stream requests a distribution we don't know about.
	 */
	public void loadVulnerability(InputStream inputStream, boolean isAvailable,
			boolean dieOnError) throws IOException, NullPointerException,
			SAXException, UnsupportedDistributionException {
		
		VulnerabilityModel newModel = null;
		try  {
			newModel = DiscreteVulnerabilityFactory.createVulnerability(
					inputStream);
		} catch (IllegalVulnerabilityFormatException ivx) {
			// The continuous factory does not yet exist...
			//newModel = ContinuousVulnerabilityFactory.createVulnerability(
			//		inputStream);
		} finally {
			loadVulnerability(newModel, isAvailable);
		}
	}
	
	/**
	 * Loads the given <code>model</code> as a known vulnerability and
	 * conditionally sets the availability to of this model to <code>true</code>.
	 * Node: Availability is a future feature when vulnerabilities are only
	 * available for selected structures and vice-versa. Currently they should
	 * all always be available.
	 * 
	 * @param model The vulnerability model to load.
	 * @param isAvailable <code>true</code> if the model should be considered
	 * available, <code>false</code> otherwise.
	 * 
	 * @throws NullPointerException If the given <code>model</code> is
	 * <code>null</code>.
	 */
	public void loadVulnerability(VulnerabilityModel model, boolean isAvailable)
			throws NullPointerException {
		if(model == null) {
			NullPointerException npx = new NullPointerException(
				"Cannot add a null vulnerability.");
			npx.fillInStackTrace();
			throw npx;
		}
		knownModels.put(model.getName(), model);
		if(isAvailable) {
			enableModel(model);
		}
	}
	
	//---------------------------------------------------------------------------
	// Private Methods
	//---------------------------------------------------------------------------
}
