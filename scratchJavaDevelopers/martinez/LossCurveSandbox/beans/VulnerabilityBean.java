package scratchJavaDevelopers.martinez.LossCurveSandbox.beans;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.TreeMap;

import scratchJavaDevelopers.martinez.LossCurveSandbox.ui.BeanEditorAPI;
import scratchJavaDevelopers.martinez.LossCurveSandbox.ui.
		VulnerabilityBeanEditor;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		DiscreteVulnerabilityFactory;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		IllegalVulnerabilityFormatException;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		UnsupportedDistributionException;
import scratchJavaDevelopers.martinez.LossCurveSandbox.vulnerability.
		VulnerabilityModel;

/**
 * <p>
 * A vulnerability bean is a widget component used to store information about
 * vulnerabilities. Vulnerabilities are loaded from input data files (some by
 * default, and others can be loaded from the user). Once the vulnerability is
 * loaded it is considered to be &ldquo;known&rdquo;. Additionally, there is a
 * concept of availability. In its initial implementation, all vulnerabilities
 * are available all the time, however in reality this makes less sense. Certain
 * vulnerabilities are only meant to be used with certain structures (this is a
 * many-to-many relationship). Once the concept of different structure types is
 * implemented then this class should be refactored to include that
 * functionality as well.
 * </p>
 * <p>
 * Some of this beans properties are bound and/or constrained and an interested
 * listener can be added via utility method to listen for a named property. The
 * handling of this is done using the
 * <code>java.beans.PropertyChangeSupport</code> and
 * <code>java.beans.VetoableChangeSupport</code> utility classes. See the Java
 * Bean specification for more details.
 * </p>
 * <p>
 * This bean supports the singleton design structure such that multiple editors
 * can be used to display this same information in a number of different
 * locations at once. Due to this shared-object structure, it is important to
 * note that all read/write methods contained within are synchronized to prevent
 * dual access.
 * </p>
 * 
 * @author <a href="mailto:emartinez@usgs.gov">Eric Martinez</a>
 *
 */
public class VulnerabilityBean implements BeanAPI, VetoableChangeListener {
	
	//---------------------------------------------------------------------------
	// Member Variables
	//---------------------------------------------------------------------------
	
	// Explicitly declared for serialization.
	private static final long serialVersionUID = 0x2F9E201;
	
	// Extension of file to look for when searching recursively for input files.
	private static final String INPUT_FILE_EXTENSION = ".xls";
	
	// Name of file to look  for when searching recursively for input files.
	private static final String INPUT_FILE_NAME =
			"vulnerability" + INPUT_FILE_EXTENSION;
	
	// Prompt for user when we find a file that *might* be an input file.
	private static final String ASK_USER_ABOUT_FILE = "The file (%s) was " +
			"found while recursively searching the directory. It might be a " +
			"valid input file. Would you like to try to parse it?";
	
	// Prompt for user when parsing of a *possible* input file fails.
	private static final String ASK_USER_CATCH_ERRORS = "The file (%s) was " +
			"not a valid file format for creating any known type of " +
			"vulnerability. Would you like to ignore it and continue?";
	
	/**
	 * This is the singleton instance of this class. All callers will receive
	 * this instance when requesting <code>getInstance</code>. The singleton
	 * structure is used such that many editors can display the same information
	 * to users.
	 */
	private static VulnerabilityBean instance = null;
	
	/**
	 * The currently selected vulnerability model.
	 */
	private VulnerabilityModel currentModel = null;
	/**
	 * A mapping of known models with their current respective availabilities.
	 */
	private TreeMap<VulnerabilityModel, Boolean> knownModels = null;
	/**
	 * The editor used to manipulate values on this bean.
	 */
	private VulnerabilityBeanEditor editor = null;
	
	/**
	 * A utility object used to manage property change events.
	 */
	private PropertyChangeSupport propertyManager = null;
	
	/**
	 * A utility object used to manage veto-able property changes and vetoes.
	 */
	private VetoableChangeSupport changeManager = null;
	
	/**
	 * The name of the property for the current model. Useful when a listener
	 * wants to listen for changes to this property.
	 */
	public static final String CURRENT_MODEL_PROPERTY = "currentModel";
	
	/**
	 * The name of the property listing known models.
	 */
	public static final String KNOWN_MODELS_PROPERTY = "knownModels";
	
	/**
	 * The name of the property for the editor used to manipulate this bean.
	 */
	public static final String EDITOR_PROPERTY = "editor";

	//---------------------------------------------------------------------------
	// Constructors/Initializers
	//---------------------------------------------------------------------------

	/**
	 * A default no-arg constructor. Initializes required variables such that
	 * subsequent call to this bean should not directly cause an exception. This
	 * constructor loads vulnerabilities from the default location and lists
	 * them as available to a caller.
	 */
	private VulnerabilityBean() {
		knownModels = new TreeMap<VulnerabilityModel, Boolean>();
		
		// Instantiate the property manager
		propertyManager = new PropertyChangeSupport(this);
		
		// Instantiate the change manager
		changeManager = new VetoableChangeSupport(this);
		addVetoableChangeListener(CURRENT_MODEL_PROPERTY, this); // Listen
	}
	
	/**
	 * The preferred way to instantiate a vulnerability bean. Use of this method
	 * ensures the singleton design architecture and allows many editors to
	 * display the same information to the user.
	 * 
	 * @return The singleton instance of this class.
	 */
	public static synchronized VulnerabilityBean getInstance() {
		if(instance == null) {
			instance = new VulnerabilityBean();
		}
		return instance;
	}
	
	//---------------------------------------------------------------------------
	// Public Methods
	//---------------------------------------------------------------------------
	
	//---------------------- Public Setter Methods ----------------------------//
	
	/**
	 * Sets the <code>currentModel</code> to the given <code>model</code>. Since
	 * this property is constrained to available models, this constraint is
	 * checked by all veto-able property change listeners of this bean to ensure
	 * availability. If any listener objects to the change the value is reverted
	 * to its old value. Interested listeners should listen to this bean's
	 * <code>CURRENT_MODEL_PROPERTY</code> property to be informed of changes.
	 * 
	 * @param model The vulnerability model to set as current.
	 * @return The name of the model that is currently active.
	 */
	public synchronized VulnerabilityModel setCurrentModel(
			VulnerabilityModel model) {
		// This is a constrained property, so 
		try {
			// Let interested objects veto if they want to...
			changeManager.fireVetoableChange(CURRENT_MODEL_PROPERTY,
					currentModel, model);
			
			// Store this away for later...
			VulnerabilityModel oldModel = currentModel;
			
			currentModel = model;
			
			propertyManager.firePropertyChange(CURRENT_MODEL_PROPERTY,
					oldModel, currentModel);
			
			return currentModel;
		} catch (PropertyVetoException pvx) {
			// Revert to old value and via recursion, re-notify
			return setCurrentModel(currentModel);
		}
	}

	/**
	 * </p>
	 * Attempts to parse  the given <code>inputFile</code> to create a 
	 * <code>VulnerabilityModel</code>. If parsing succeeds, then this model
	 * is added to the list of <code>knownModels</code> and depending on the
	 * given value of <code>enabled</code> is optionally set as available.
	 * </p>
	 * <p>
	 * If the <code>inputFile</code> is a directory rather than an actual file
	 * then the directory is recursively searched for a file named
	 * <code>INPUT_FILE_NAME</code>, or for and file ending with
	 * <code>INPUT_FILE_EXTENSION</code>. If the exact name is found, then it
	 * is silently loaded and parse errors will cause a halt in the runtime
	 * execution. If only the extension is matched, then the user is given the
	 * choice to try to parse the file and upon parse failure is asked if runtime
	 * execution should halt execution or ignore it and continue.
	 * </p>
	 * 
	 * @param inputFile The input file (or directory) to parse.
	 * @param enabled <code>true</code> if the resulting model should currently
	 * be considered enabled, <code>false</code> otherwise.
	 * @throws FileNotFoundException If the specified <code>inputFile</code> is
	 * not found.
	 * @throws IOException If an I/O error occurs while reading the
	 * <code>inputFile</code>.
	 * @throws UnsupportedDistributionException If the <code>inputFile</code>
	 * specifies a probabilistically distributed model but requests an unknown
	 * probability distribution function.
	 * @throws IllegalVulnerabilityFormatException If the <code>inputFile</code>
	 * is poorly formatted XML or does not follow the specification for a
	 * vulnerability model input file.
	 */
	public synchronized void updateModels(File inputFile, boolean enabled) 
			throws FileNotFoundException, IOException, 
			UnsupportedDistributionException, IllegalVulnerabilityFormatException {
		
		if(inputFile.isDirectory()) {
			// Loop over all sub directories looking for an input file
			File[] fileList = inputFile.listFiles();
			for(int i = 0; i < fileList.length; ++i) {
				updateModels(fileList[i], enabled);
			}
		} else {
			// This is (or may be) an input file. Do it (or ask user first).
			String inputFileName = inputFile.getName();
			if(inputFileName.contains(INPUT_FILE_NAME) ||
					(
							inputFileName.endsWith(INPUT_FILE_EXTENSION) &&
							editor.boolPrompt(String.format(ASK_USER_ABOUT_FILE, 
									inputFileName), true)
					)
				) {
				try {
					// Try to create the model and add it
					updateModels(new FileInputStream(inputFile), enabled);
				} catch (IllegalVulnerabilityFormatException ivx) {
					// Ask user if they want to stop execution because of this error.
					if(!editor.boolPrompt(String.format(ASK_USER_CATCH_ERRORS,
								inputFileName), true)
							) {
						throw ivx;
					}
				}
			}
		}
	}
	
	/**
	 * Attempts to read the given input stream <code>in</code> and parse a
	 * vulnerability model out of it. If parsing succeeds, then the resulting
	 * model is added to the list of <code>knownModels</code> and its current
	 * availability is set according to the value of <code>enabled</code>.
	 * 
	 * @param in The input stream to read.
	 * @param enabled <code>true</code> if the resulting model should currently
	 * be considered available, <code>false</code> otherwise.
	 * @throws IOException If an I/O error occurs while reading the input stream.
	 * @throws UnsupportedDistributionException If the input stream defines a
	 * probabilistically distributed vulnerability model but requests the user
	 * of a probability distribution that is not  known.
	 * @throws NullPointerException If the resulting model after parsing the
	 * input is <code>null</code>.
	 * @throws IllegalVulnerabilityFormatException If the input specifies poorly
	 * formatted XML or does not follow the specification for vulnerability
	 * model input.
	 */
	public synchronized void updateModels(InputStream in, boolean enabled) 
			throws IOException, UnsupportedDistributionException,
			NullPointerException, IllegalVulnerabilityFormatException {
		VulnerabilityModel model = null;
		
		try {
			// Try a discrete vulnerability first...
			model = DiscreteVulnerabilityFactory.createVulnerability(in);
		} catch (IllegalVulnerabilityFormatException e) {
			// Continuous factory is not implemeneted yet...
			
			// This may also result in an exception which is why we declare one to
			// be thrown in the method signature.
			
			//model = ContinuousVulnerabilityFactory.createVulnerability(in);
		}
		
		setAvailability(model, enabled);
	}
	
	/**
	 * Updates the given <code>model</code>'s availability based on the given
	 * value of <code>enabled</code>. If the model is not currently known, it is
	 * added to this list so long as it is not <code>null</code>. Interested 
	 * listeners should listen to this bean's <code>KNOWN_MODELS_PROPERTY</code>
	 * property to be informed of changes. This property is not constrained and
	 * changes here cannot be vetoed.
	 * 
	 * @param model The model to update (or add).
	 * @param enabled <code>true</code> if the model is currently available,
	 * <code>false</code> otherwise.
	 * @throws NullPointerException If the <code>model</code> is
	 * <code>null</code>.
	 */
	public synchronized void setAvailability(VulnerabilityModel model,
			boolean enabled) throws NullPointerException {
		
		// Check for null, throw exception if so...
		if(model == null) {
			String value = "";
			if(enabled) { value = "enable"; } else { value = "disable"; }
			NullPointerException npx = new NullPointerException("Attempted to " +
					value + " a null vulnerability model.");
			npx.fillInStackTrace();
			throw npx;
		}

		// Store away for later...
		TreeMap<VulnerabilityModel, Boolean> oldValue = knownModels;
		
		// Update the list
		knownModels.put(model, new Boolean(enabled));
		
		// Let listeners know about the change...
		propertyManager.firePropertyChange(KNOWN_MODELS_PROPERTY,
				oldValue, knownModels);
	}
	
	/**
	 * Set the editor used to modify this bean. Interested listeners should
	 * listen to this bean's <code>EDITOR_PROPERTY</code> property to be informed
	 * of changes. This property is not constrained and changes here cannot be
	 * vetoed. If multiple editors are set in succession, only the most recent
	 * is used to alert the user of something, however all editors may still
	 * accept user input and change values.
	 * 
	 * @param editor The new editor used.
	 */
	public synchronized void setEditor(VulnerabilityBeanEditor editor) {
		// Store the old value for notification
		BeanEditorAPI oldEditor = this.editor;
		
		// Make the change
		this.editor = editor;
		
		// Fire the change event to any listeners
		propertyManager.firePropertyChange(EDITOR_PROPERTY, 
				oldEditor, this.editor);
	}
	
	//---------------------- Public Getter Methods ----------------------------//
	
	/**
	 * @return The currently selected vulnerability model.
	 */
	public synchronized VulnerabilityModel getCurrentModel() {
		return currentModel;
	}
	
	/**
	 * @return A list of available currently vulnerability models.
	 */
	public synchronized ArrayList<VulnerabilityModel> getAvailableModels() {
		ArrayList<VulnerabilityModel> availableModels =
			new ArrayList<VulnerabilityModel>();
		
		Iterator<VulnerabilityModel> iter = knownModels.keySet().iterator();
		
		while(iter.hasNext()) {
			VulnerabilityModel model = iter.next();
			if(knownModels.get(model).booleanValue()) {
				availableModels.add(model);
			}
			
		}
		
		return availableModels;
	}
	
	/**
	 * @return A list of known vulnerability models with their current
	 * corresponding availability.
	 */
	public synchronized TreeMap<VulnerabilityModel, Boolean> getKnownModels() {
		return knownModels;
	}
	
	/**
	 * Checks whether or not a specific vulnerability is currently available.
	 * 
	 * @param model The vulnerability to look for.
	 * @return <code>true</code> if the vulnerability is available, 
	 * <code>false</code> otherwise.
	 */
	public synchronized boolean isAvailable(VulnerabilityModel model) {
		Boolean availability = knownModels.get(model);
		if(availability == null) {
			return false;
		} else {
			return availability.booleanValue();
		}
	}
	
	/**
	 * @return The editor used to manipulate this bean.
	 */
	public synchronized VulnerabilityBeanEditor getBeanEditor() {
		return editor;
	}
	
	//---------------------- Public Utility Methods ---------------------------//
	
	/**
	 * Wrapper method to allow external objects to add listeners to this bean's
	 * property changes.
	 * 
	 * @param propertyName The name of the property of interest.
	 * @param listener The listener who is interested in changes.
	 */
	public void addPropertyChangeListener(String propertyName,
			PropertyChangeListener listener) {
		propertyManager.addPropertyChangeListener(propertyName, listener);
	}
	
	/**
	 * Wrapper method to allow external objects to remove themselves as one of
	 * this bean's property change listeners.
	 * 
	 * @param propertyName The name of the property no longer of interest.
	 * @param listener The listener who is no longer interested in changes.
	 */
	public void removePropertyChangeListener(String propertyName,
			PropertyChangeListener listener) {
		propertyManager.removePropertyChangeListener(propertyName, listener);
	}
	
	/**
	 * Wrapper method to allow external objects to add themselves as a listener
	 * and objector to changes on this bean's properties.
	 * 
	 * @param propertyName The name of the property to listen for changes to.
	 * @param listener The listener interested in changes.
	 */
	public void addVetoableChangeListener(String propertyName,
			VetoableChangeListener listener) {
		changeManager.addVetoableChangeListener(propertyName, listener);
	}
	
	/**
	 * Wrapper method to allow external objects to remove themselves as a
	 * listener or objector to changes on this bean's properties.
	 * 
	 * @param propertyName The name of the property no longer of interest.
	 * @param listener The listener no longer interested in changes.
	 */
	public void removeVetoableChangeListener(String propertyName,
			VetoableChangeListener listener) {
		changeManager.removeVetoableChangeListener(propertyName, listener);
	}
	
	/**
	 * Method to implement the <code>VetoableChangeListener</code> interface.
	 * Checks to  ensure the model we are trying to set as the
	 * <code>currentModel</code> is currently available. The
	 * <code>currentModel</code> is the only constrained bean property.
	 */
	public void vetoableChange(PropertyChangeEvent evt) 
			throws PropertyVetoException {
		
		if(CURRENT_MODEL_PROPERTY.equals(evt.getPropertyName()) ) {
			// Make sure the requested property is currently available
			if(	!isAvailable( (VulnerabilityModel) evt.getNewValue()) ) {
				throw new PropertyVetoException("The requested model is not " + 
						"currently available.", evt);
			}
			// The change seems to be okay so do not throw exception.
			
		}
	}
	//---------------------------------------------------------------------------
	// Private Methods
	//---------------------------------------------------------------------------
}
