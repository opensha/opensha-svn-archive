**************** SHORT TERM (HIGH PRIORITY): ****************
-------------------------------------------------------------

Implement time-dep and time-ind options in UCERF 1.0 using one of the following two solutions.  1) extend timeSpan and the editor to have a TimeDepAndIndSupported and an associated timeDep boolean (former says allow user to toggle between the two, and the latter declares the present state); 2) put the timeDepBooleanParam in with the other adjustable ERF params and if this state changes, have the ERF issue a timeSpanChange event (not just a timeSpanValueChange event) - this way the app will know to get the new timeSpan and show it in the GUI.  The 2nd option is preferred, but will require an object on the server to be able to send an event to the application; Nitin is exploring whether this will be possible.

In save PDF image option, take out empty line before the "__________", and change mouse over to "Save graph and metadata as PDF".

Validate & polish the disaggregation plotting (Nitin & Ned together).  Do the boxes sum to 1?

For the deterministic calc option in the HazardCurveApps, make it so the IRM parameters in the metadata include the eqkRup and propEffect params from the IMR (so users can reproduce the results using the attenuation-relationship application). Ned should also look at the new method for this in the calculator.  Also, turn disaggregation off if one has chosen determinitistic.

Update the HazardSpectrumApp with latest GUI beans.

Explore source and rupture visualization options, including JFreeChart, GMT, GoogleEarth, and VDO.  Build the visualization of sources (we added a getAllSourceLocs() method to all sources) and/or ruptures & associated info into the applications (especially for deterministic calcs).  Also include plotting MFDs for sources.  Vipin

Get feedback on CA Ref. Fault Param. Database GUI (Vipin)

Continue working on the all-ruptures-in-fault-system tool (Vipin)

Create ability to map rate(³M,lat,lon) and plot MFD(region) for any ERF (needed for RELM).

Implement the attenuation relationship desired by UCLA.  This will require allowing an IMR to issue a supportedIMT_Change event so the applications can refresh accordingly.  This will also require an object on the server to communicate with an application if we ever distribute IMRs.

UCERF 1.0 validation (Ned)

Vs30 worldwide tool (Ned should talk to David Wald)

ERF2GriddedSeisRateCalc - Ned needs to look it over.

Work on html-based help documentation


HypoMagFreqDistAtLoc:

	Remove editable and all set methods
	Remove ignoreFocalMech and just do that if it's null
	Make MagFreqDist and FocMech arrays of each to support multiple foc mech
	Loc can be null if it's not needed.

	Might want to subclass to take EvenlyGriddedRegion and index.

GriddedHypoMagFreqDistAtLocAPI

	change getHypRatesAtLoc() to getHypoMagFreqDistAtLoc()
	change getNumHypoLocation() to getNumHypoMagFreqDistAtLocs()
	Take "Gridded out of class name.

GriddedHypoMagFreqDistForecast

	remove editable boolean
	needs get/set methods for adjustable parameters. 
	Add evenlyGriddedRegion with get, but no set method.
	Make this abstract (ERF wrapper will be subclass)
	Note that indexing on HypMagFreqDistAtLocs is exactly the same as for griddedRegion

AfterShockHypoMagFreqDistForecast

	add set method for griddedRegion (defined in parent), and change name to aftershockZone


EvenlyGriddedGeographicRegions

	make all extend EvenlyGriddedGeographicRegion to share methods

	Change getGridLocation(int index,EvenlyGriddedGeographicRegionAPI region) to
	getNearestGridLocation(int index,EvenlyGriddedGeographicRegionAPI region)

	Have methods return null if loc or index not in region.

        Document the following in either EvenlyGriddedGeographicRegion or EvenlyGriddedGeographicRegionAPI:

		1) that methods return null if ...
		2) ordering of locs in region is as reading a book
		3) nice grid values
		4) pointers returned for speed (at sacrifice of memory because e3ntire list is created); 
		otherwise use get*Clone* methods.
		5)


Nitin has to look on how to get the OpenSHA code to the source-forge.

Implement:

	CubeObsEqkRuptureGeneratior - makes ObsEqkRupture(s) from a String (of list of Strings)

	ObsEqkRuptureList - w/ all the sorting, subset selection methods

	ObsEqkRuptureListCalc - various general calcs with respect to an ObsEqkRuptureList

	MagCompletenessCalc

	GR_fitParamsCalc

	OmoriLawFitParamsCalc  

		(These last three should be able to take an ObsEqkRuptureList or input data 
		 as double[] objects for maximum efficiency and flexibility)

	Other classes .................. (once done tell ned and he'll update STEP doc)


Create a SausageGeographicRegion that takes a locListLine and radius as input and constructs a polygon such that each point on the polygon is ~radius from the line defined by locListLine.  Note that LocationList has the method getMinHorzDistToLine(loc) which could be useful here.  Note also that some of the presently private attributes in the parent class (GeographicRegion) could be useful if made protected.  Note also that the polygon does not need to be created until asked for.

Create an EvenlyGriddedSausageGeographicRegion (may want to compute locations simultaneously with the polygon in the parent class, SausageGeographicRegion, for efficiency).

Create a GeographicRegionAroundEqkRupture subclass of GeographicRegion that takes an EqkRupture and radius and creates a polygon such that each point on the polygon is ~radius from the edge of the horizontal projection of the eqkRupture surface.  Create and EvenlyGridded version of this.

Prepare a brief documentation on the how and why I did HazardCurveServer Mode in RMI. This will also include preparing a brief documentation on RMI and webservices. This document should also include the possible flaws in the applications and what improvements are needed in the application and what's more needs to be added to generalize the application.  Nitin

Work on the data file provided by NGA to get the Observed EqkRuptures from them and create the HazardCurve for these ruptures.

Revisit PEER results plotter & data submission tool.

Investigate what proper longitude limits are with respect to RelativeLocation, 0 to 360, -180 to 180, -180 to 360, or -360 to 360.

Distance Calculations : Approx Horizontal Distance(getApproxHorzDistance()) calculator does not calculate the correct distance if longitude is > 0. But Horizontal Distance(getHorzDistance()) always calculate the accurate distance. (Nitin tested using main() method in RelativeLocation class, one can just run the RelativeLocation class and will get to know the difference).

Fix GriddedFaultApplet - horz/vert scaling - may be fixed; check it out; add java 3D.  Or should we use LA 3D?

Ned needs to document WG02_EqkRupForecast (Java docs).

Implement color schemes at (including option for the visually impaired):

	http://geography.uoregon.edu/datagraphics/color_scales.htm

Add faults to GMT plotting options.

add site translation for SEA_1999_AttenRel

Revise CVS setup document. It should includes the libraries that the person needs to include and classes that needs to be compiled as RMI.

Implement point source correction option in PropagationEffect.

Make email lists for the following (with on-line archives):

	users@OpenSHA.org
	developers@OpenSHA.org
	leaders@OpenSHA.org
	advisors@OpenSHA.org

Figure out how to add the OpenSHA logo to shakeMaps.

Peter Powers' stress chance calculator (and Jeremy's work)?

Formally test all applications before publication (this will take planning).

Create capability to associate IMRs to specific source types in the calculations (this will take some thought and perhaps some communication with Golden).  Ned's intitial tests on adding such fields to EqkRupture does not significantly increase memory requirements.  Possibilities:

	Subduction Interface
	Subduction IntraSlab
	Shallow Crustal in Active Tectonic Regions
	Shallow Crustal in Stable Tectonic Regions

Re-calculate the PEER set2, case5 (including fractiles) and update the Excel spreadsheet (I changed the implementation and I believe it is now correct).

Look into how to save an application in its current state (and to an abitrary file name) so that a user can double click later to come back.

Find a database we can reference for lat/lon values of cities in California.  Add some of these to the control panel.  Nitin has one.  Make a web service?

Solve Our MetaData Issues.  We need to be able to do three things: 1) inform the user what they are looking at in a plot (this is done); 2) save the state of a stand-alone app on the user's computer so they can relaunch later and begin where they left off; and 3) save enough information to the SRB (or equivalent) so we can tell at runtime whether a calculation has already been done, or so other's browsing the SRB will see what's available. This raises issues with respect to allowed characters in a parameter name.  Why don't we reserve the following special characters for writing the string-representation of metadata (meaning these can't be used in parameter names):

	=	- separate name/value pairs
	;	- to separate parameters
	[	- to encapsulate dependent params
	]	- to encapsulate dependent params
	:	- for writing out parameterList (or GuiBean) values (also "----" under these?)

	Check for these in the setName() methods?

	Can we avoid such special character issues using XML representation (for the case where
	we read values back in to redo a calculation)?

	With respect to GuiBeans we have discussed two approaches.  Let's take the ERF_GuiBean as
	an example.  One mode (mentioned above) is to read back in the parameter settings (from XML),
	set the parameter values accordingly, and then recreate the ERF.  If the ERF is very time
	consuming to create, then the second mode would be to read back in the serialized version
	of the object, and since all the parameter are already set, the GuiBean would not have to
	do anything.  Note that all non primitive parameter types (e.g., MagFreqDistParam and
	SimpleFaultParam) must contain all info needed by their respective editor to recreate the
	object; this info is stored in their dependent parameter list.

SimpleListricGriddedFaultFactory has problem - run main method to find it.  Ned will look at this.

Should we create an AjustableParametersAPI for all objects that have a list of adjustable parameters?

**************** LONG TERM (LOWER PRIORITY): ****************
-------------------------------------------------------------


Relax the single ERF instance at one time in the ERF and RupFroERF GUI beans if needed and memory is not an issue.

Implement NGA relationships when ready.

ProbEqkSource	Define field to declare what type of source it is
		(e.g., subduction zone vs normal vs reverse ...) and add to API.
		Ned will work on what the various options should be.

ERF		-extend API to include getting max and min magnitude, and the various types of
		sources generated (to check for compatibility with each chosen IMR)

Ned - Run a forecast with non-zero mags up to mag 10 to search for numerical breakdowns (e.g., Math.pow(-num, non-integer) ) or search for for Math.pow.

EvenlyGriddedSurface: have the getAveDip() method compute the dip explicitly (in case it's a subset of a listric fault)?

(even lower priority below)

Allow choosing of multiple ERFs (e.g., hand built ERF_EpistemicList)

Implement getApplicableRegion() and isLocWithinApplicableRegion() methods in implemented ERFs.

DisaggregationCalculator is similar to HazardCurveCalculator; should the two be combined?

IMT_GuiBean - the loop over independent parameters of the chosen IMT can presently deal only with DoubleDiscreteParameter objects (rather than any parameter type).  Should we generalize this?

Decide how to handle rake=NaN in each IMR (can rake-NaN in an EarthquakeRupture object?).

Decide on and implement a licensing agreement.

Vector PSHA?

Pathway 1.5?

AttenRelApp:

	Problem:  if you violate a parameter constraint when hitting the add trace button
	(rather than hitting return in the parameter editor) you need to hit add trace again
	if you accept the value.  Nitin and Vipin say this is a problem with Java (focus at
	time of exception throwing is lost).

JFreechart problem: If the the upperBound and lowerBound of the axis are the same then JFreechart only adds a small increment to axis range, so because of this in our AttenuationRelaitonshipApp when we choose the BJF attenRel and on Y-Axis choose the Std. Dev. we get same values for all X-values. In other words, our lowerBound and upperBound are the same. JFrechart does provide a method to handle and specify minimum range between the Upperbound and LowerBound of the axis but we can't just add a number to specify the range.

